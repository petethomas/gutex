<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Gutex</title>
  <!-- Theme fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Share+Tech+Mono&family=Lora:ital,wght@0,400;0,600;1,400&family=Roboto+Mono:wght@400;500&family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Playfair+Display:ital,wght@0,400;0,600;1,400&family=Bitter:wght@400;500;700&family=Cinzel:wght@400;600&family=Raleway:wght@300;400;500&family=Space+Mono:wght@400;700&family=Merriweather:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-vnjNSDGjn2um_Ck72v_qw.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
  <style>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Prevent scrollbar layout shunting - always reserve scrollbar gutter */
    html {
      overflow-y: scroll;
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }

    :root {
      --touch-min: 44px;
      --spacing-sm: 8px;
      --spacing-md: 12px;
      --spacing-lg: 20px;
      
      /* Theme fonts - default */
      --font-body: Georgia, 'Times New Roman', serif;
      --font-ui: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-mono: 'SF Mono', Consolas, monospace;
      
      /* Theme colors - default */
      --bg-primary: #fff;
      --bg-secondary: #f8f8f8;
      --bg-tertiary: #f0f0f0;
      --text-primary: #000;
      --text-secondary: #333;
      --text-muted: #666;
      --text-faint: #999;
      --border-color: #ccc;
      --border-light: #e0e0e0;
      --accent-color: #333;
      --accent-hover: #555;
      --btn-bg: #fff;
      --btn-hover: #f0f0f0;
      --btn-active: #e0e0e0;
      --modal-bg: rgba(255, 255, 255, 0.98);
      --modal-shadow: rgba(0, 0, 0, 0.15);
      --hint-bg: rgba(0, 0, 0, 0.85);
      --hint-text: #fff;
      --canvas-bg: #fff;
      --rope-text: #000;
      --success-bg: #d4edda;
      --success-border: #28a745;
      --success-text: #155724;
      --danger-bg: #f8d7da;
      --danger-border: #dc3545;
      --danger-text: #721c24;
    }

    /* Dark Mode Theme */
    [data-theme="dark"] {
      --font-body: Georgia, 'Times New Roman', serif;
      --font-ui: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-mono: 'SF Mono', Consolas, monospace;
      --bg-primary: #1a1a1a;
      --bg-secondary: #242424;
      --bg-tertiary: #2a2a2a;
      --text-primary: #e8e8e8;
      --text-secondary: #ccc;
      --text-muted: #888;
      --text-faint: #666;
      --border-color: #444;
      --border-light: #333;
      --accent-color: #e8e8e8;
      --accent-hover: #fff;
      --btn-bg: #2a2a2a;
      --btn-hover: #3a3a3a;
      --btn-active: #444;
      --modal-bg: rgba(30, 30, 30, 0.98);
      --modal-shadow: rgba(0, 0, 0, 0.5);
      --hint-bg: rgba(255, 255, 255, 0.9);
      --hint-text: #1a1a1a;
      --canvas-bg: #1a1a1a;
      --rope-text: #e8e8e8;
      --success-bg: #1a3d2a;
      --success-border: #28a745;
      --success-text: #7ddf9a;
      --danger-bg: #3d1a1a;
      --danger-border: #dc3545;
      --danger-text: #f5a5a5;
    }

    /* Sci-Fi Theme */
    [data-theme="scifi"] {
      --font-body: 'Orbitron', 'Share Tech Mono', monospace;
      --font-ui: 'Share Tech Mono', 'Orbitron', monospace;
      --font-mono: 'Share Tech Mono', monospace;
      --bg-primary: #0d0d1a;
      --bg-secondary: #151528;
      --bg-tertiary: #1a1a35;
      --text-primary: #00ffff;
      --text-secondary: #00cccc;
      --text-muted: #7777aa;
      --text-faint: #5555aa;
      --border-color: #3333aa;
      --border-light: #2222aa;
      --accent-color: #ff00ff;
      --accent-hover: #ff66ff;
      --btn-bg: #1a1a35;
      --btn-hover: #252550;
      --btn-active: #3333aa;
      --modal-bg: rgba(13, 13, 26, 0.98);
      --modal-shadow: rgba(0, 255, 255, 0.2);
      --hint-bg: rgba(255, 0, 255, 0.9);
      --hint-text: #fff;
      --canvas-bg: #0d0d1a;
      --rope-text: #00ffff;
      --nav-bg: #0a0a15;
      --nav-text: #00ffff;
      --nav-border: #3333aa;
      --scifi-glow: 0 0 10px rgba(0, 255, 255, 0.3);
      --scifi-btn-text: #00ffff;
      --progress-bar-color: #ff00ff;
      --success-bg: #0a2a1a;
      --success-border: #00ff88;
      --success-text: #00ff88;
      --danger-bg: #2a0a1a;
      --danger-border: #ff0066;
      --danger-text: #ff6699;
    }

    /* Greenfield Theme - Deep forest aesthetic */
    [data-theme="greenfield"] {
      --font-body: 'Bitter', Georgia, serif;
      --font-ui: 'Bitter', Georgia, serif;
      --font-mono: 'Space Mono', monospace;
      --bg-primary: #f0f5f1;
      --bg-secondary: #e5ede7;
      --bg-tertiary: #d8e5db;
      --text-primary: #1a2e1c;
      --text-secondary: #2a4a2e;
      --text-muted: #4a6a4e;
      --text-faint: #6a8a6e;
      --border-color: #6b8f70;
      --border-light: #8ab090;
      --accent-color: #2d5a32;
      --accent-hover: #3a7540;
      --btn-bg: #e8f0ea;
      --btn-hover: #d5e5d8;
      --btn-active: #c0d8c5;
      --modal-bg: rgba(240, 245, 241, 0.98);
      --modal-shadow: rgba(45, 90, 50, 0.2);
      --hint-bg: rgba(35, 65, 40, 0.92);
      --hint-text: #e0f0e5;
      --canvas-bg: #f0f5f1;
      --rope-text: #1a2e1c;
      --nav-bg: #1e3a22;
      --nav-text: #c5e0ca;
      --nav-border: #2d5530;
      --success-bg: #c5e8ca;
      --success-border: #2d5a32;
      --success-text: #1a3d1c;
      --danger-bg: #f5d8d8;
      --danger-border: #a54545;
      --danger-text: #6a2525;
    }

    /* Stoneworks Theme - Industrial monolith aesthetic */
    [data-theme="stoneworks"] {
      --font-body: 'Cinzel', 'Times New Roman', serif;
      --font-ui: 'Raleway', 'Helvetica Neue', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --bg-primary: #262626;
      --bg-secondary: #303030;
      --bg-tertiary: #3a3a3a;
      --text-primary: #d0d0d0;
      --text-secondary: #b0b0b0;
      --text-muted: #808080;
      --text-faint: #606060;
      --border-color: #484848;
      --border-light: #404040;
      --accent-color: #a0a0a0;
      --accent-hover: #c0c0c0;
      --btn-bg: #353535;
      --btn-hover: #454545;
      --btn-active: #505050;
      --modal-bg: rgba(38, 38, 38, 0.98);
      --modal-shadow: rgba(0, 0, 0, 0.5);
      --hint-bg: rgba(200, 200, 200, 0.95);
      --hint-text: #1a1a1a;
      --canvas-bg: #262626;
      --rope-text: #d0d0d0;
      --nav-bg: #1a1a1a;
      --nav-text: #888;
      --nav-border: #333;
      --success-bg: #2a3a2a;
      --success-border: #6a8a6a;
      --success-text: #a0c0a0;
      --danger-bg: #3a2a2a;
      --danger-border: #8a5a5a;
      --danger-text: #d0a0a0;
    }

    /* Redbrick Theme - Warm library aesthetic */
    [data-theme="redbrick"] {
      --font-body: 'Playfair Display', Georgia, serif;
      --font-ui: 'Merriweather', Georgia, serif;
      --font-mono: 'Space Mono', monospace;
      --bg-primary: #faf6f2;
      --bg-secondary: #f4ebe3;
      --bg-tertiary: #edddd0;
      --text-primary: #3d231a;
      --text-secondary: #5a3528;
      --text-muted: #7a5548;
      --text-faint: #9a7568;
      --border-color: #c4957a;
      --border-light: #d8b8a0;
      --accent-color: #8b3a2a;
      --accent-hover: #a84a38;
      --btn-bg: #f8f0e8;
      --btn-hover: #f0e0d0;
      --btn-active: #e5d0c0;
      --modal-bg: rgba(250, 246, 242, 0.98);
      --modal-shadow: rgba(139, 58, 42, 0.2);
      --hint-bg: rgba(90, 35, 25, 0.92);
      --hint-text: #f5e5dd;
      --canvas-bg: #faf6f2;
      --rope-text: #3d231a;
      --nav-bg: #4a201a;
      --nav-text: #e8c8b8;
      --nav-border: #6a302a;
      --success-bg: #e8f0e0;
      --success-border: #5a7a4a;
      --success-text: #3a5030;
      --danger-bg: #f8e8e8;
      --danger-border: #9a4a4a;
      --danger-text: #6a2a2a;
    }

    /* Midnight Theme - Deep blue night aesthetic */
    [data-theme="midnight"] {
      --font-body: 'Merriweather', Georgia, serif;
      --font-ui: 'Raleway', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --bg-primary: #0f1628;
      --bg-secondary: #1a2438;
      --bg-tertiary: #243048;
      --text-primary: #c8d4e8;
      --text-secondary: #a0b0c8;
      --text-muted: #6080a0;
      --text-faint: #405878;
      --border-color: #304060;
      --border-light: #283850;
      --accent-color: #5090d0;
      --accent-hover: #60a8f0;
      --btn-bg: #1e2a40;
      --btn-hover: #2a3850;
      --btn-active: #354560;
      --modal-bg: rgba(15, 22, 40, 0.98);
      --modal-shadow: rgba(80, 144, 208, 0.2);
      --hint-bg: rgba(40, 70, 120, 0.95);
      --hint-text: #d0e0f0;
      --canvas-bg: #0f1628;
      --rope-text: #c8d4e8;
      --nav-bg: #0a1020;
      --nav-text: #8098c0;
      --nav-border: #203050;
      --success-bg: #102820;
      --success-border: #30a060;
      --success-text: #60d090;
      --danger-bg: #281018;
      --danger-border: #a03040;
      --danger-text: #f08090;
    }

    /* Amber Theme - Warm amber/sepia aesthetic */
    [data-theme="amber"] {
      --font-body: 'Bitter', Georgia, serif;
      --font-ui: 'Bitter', Georgia, serif;
      --font-mono: 'Space Mono', monospace;
      --bg-primary: #1a1408;
      --bg-secondary: #241c0c;
      --bg-tertiary: #2e2410;
      --text-primary: #f0d090;
      --text-secondary: #d0b070;
      --text-muted: #a08050;
      --text-faint: #706040;
      --border-color: #604820;
      --border-light: #483818;
      --accent-color: #e0a040;
      --accent-hover: #f0b850;
      --btn-bg: #282010;
      --btn-hover: #383018;
      --btn-active: #484020;
      --modal-bg: rgba(26, 20, 8, 0.98);
      --modal-shadow: rgba(224, 160, 64, 0.2);
      --hint-bg: rgba(60, 48, 20, 0.95);
      --hint-text: #f0d898;
      --canvas-bg: #1a1408;
      --rope-text: #f0d090;
      --nav-bg: #120c04;
      --nav-text: #c8a060;
      --nav-border: #403010;
      --success-bg: #1a2810;
      --success-border: #80a040;
      --success-text: #c0e080;
      --danger-bg: #281810;
      --danger-border: #a05040;
      --danger-text: #e0a080;
    }

    /* Theme-specific header styling for colored navbars */
    [data-theme="greenfield"] header,
    [data-theme="redbrick"] header,
    [data-theme="stoneworks"] header,
    [data-theme="midnight"] header,
    [data-theme="amber"] header {
      background: var(--nav-bg);
      border-color: var(--nav-border);
    }

    [data-theme="greenfield"] header *,
    [data-theme="redbrick"] header *,
    [data-theme="stoneworks"] header *,
    [data-theme="midnight"] header *,
    [data-theme="amber"] header * {
      color: var(--nav-text);
    }

    [data-theme="greenfield"] header button,
    [data-theme="greenfield"] header select,
    [data-theme="redbrick"] header button,
    [data-theme="redbrick"] header select,
    [data-theme="stoneworks"] header button,
    [data-theme="stoneworks"] header select,
    [data-theme="midnight"] header button,
    [data-theme="midnight"] header select,
    [data-theme="amber"] header button,
    [data-theme="amber"] header select {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--nav-text);
    }

    [data-theme="greenfield"] header button:hover,
    [data-theme="greenfield"] header select:hover,
    [data-theme="redbrick"] header button:hover,
    [data-theme="redbrick"] header select:hover,
    [data-theme="stoneworks"] header button:hover,
    [data-theme="stoneworks"] header select:hover,
    [data-theme="midnight"] header button:hover,
    [data-theme="midnight"] header select:hover,
    [data-theme="amber"] header button:hover,
    [data-theme="amber"] header select:hover {
      background: rgba(255, 255, 255, 0.18);
    }

    /* Sci-Fi theme specific styles for buttons and progress */
    [data-theme="scifi"] .nav-buttons button {
      color: var(--scifi-btn-text);
      text-shadow: var(--scifi-glow);
    }

    [data-theme="scifi"] header button,
    [data-theme="scifi"] .search-btn {
      color: var(--scifi-btn-text);
    }

    [data-theme="scifi"] .progress-bar {
      background: var(--progress-bar-color);
      box-shadow: 0 0 12px rgba(255, 0, 255, 0.6);
    }

    [data-theme="scifi"] header {
      background: var(--nav-bg);
      border-color: var(--nav-border);
      box-shadow: 0 2px 12px rgba(0, 255, 255, 0.1);
    }

    [data-theme="scifi"] footer {
      box-shadow: 0 -2px 12px rgba(0, 255, 255, 0.1);
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: var(--font-body);
      font-size: calc(clamp(16px, 4vw, 20px) * var(--text-scale, 1));
      line-height: 1.6;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      transition: background-color 0.3s, color 0.3s, font-family 0.3s;
      /* Prevent accidental zoom on mobile */
      touch-action: pan-x pan-y;
      -webkit-touch-callout: none;
    }
    
    /* Content text sizing - explicit rules for iOS stability */
    #content {
      font-size: inherit;
    }
    body.text-size-small #content { font-size: 14px; }
    body.text-size-normal #content { font-size: 17px; }
    body.text-size-large #content { font-size: 20px; }
    
    /* Mobile-specific fixed sizes to avoid viewport-dependent issues */
    @media (max-width: 768px) {
      body.text-size-small #content { font-size: 15px; }
      body.text-size-normal #content { font-size: 18px; }
      body.text-size-large #content { font-size: 21px; }
    }

    /* Text size selector - shown only in non-3D mode */
    .text-size-select {
      min-height: 32px;
      height: 32px;
      padding: 0 6px;
      font-size: 13px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--btn-bg);
      color: var(--text-primary);
      cursor: pointer;
      transition: background-color 0.15s, border-color 0.15s;
      font-family: var(--font-ui);
    }
    .text-size-select:hover { background: var(--btn-hover); }
    .text-size-select:focus { outline: 2px solid var(--accent-color); outline-offset: 1px; }
    
    /* Hide text size selector in 3D mode */
    body.mode-3d .text-size-select,
    body.mode-3d .overflow-text-size {
      display: none;
    }

    header {
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--border-color);
      font-family: var(--font-mono);
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--spacing-sm);
      background: var(--bg-primary);
      position: sticky;
      top: 0;
      z-index: 100;
      transition: background-color 0.3s, border-color 0.3s;
      flex-wrap: nowrap;
      min-height: 52px;
      /* Prevent text selection in header UI */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .nav-left {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    .nav-center {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      flex-shrink: 1;
      min-width: 0;
    }

    .nav-right {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    /* Collapsible items - hidden on narrow screens */
    .nav-collapsible {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .nav-buttons {
      display: flex;
      gap: 4px;
    }

    .nav-buttons button, .header-btn, .search-btn {
      min-width: 32px;
      min-height: 32px;
      width: 32px;
      height: 32px;
      font-size: 16px;
      cursor: pointer;
      border: 1px solid var(--border-color);
      background: var(--btn-bg);
      color: var(--text-primary);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.15s, border-color 0.15s;
    }

    .search-btn {
      border: none;
      background: transparent;
      opacity: 0.6;
      padding: 0;
    }

    .search-btn:hover { opacity: 1; }
    .search-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .nav-buttons button:hover, .header-btn:hover { background: var(--btn-hover); }
    .nav-buttons button:active, .header-btn:active { background: var(--btn-active); }
    .nav-buttons button:disabled { opacity: 0.4; cursor: not-allowed; }

    .auto-read {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .auto-read select, .auto-read button {
      height: 32px;
      min-height: 32px;
      font-size: 13px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--btn-bg);
      color: var(--text-primary);
      cursor: pointer;
      padding: 0 6px;
      transition: background-color 0.15s, border-color 0.15s;
    }

    .auto-read button { padding: 0 var(--spacing-md); }
    .auto-read button.active { background: var(--accent-color); color: var(--bg-primary); }
    .auto-read select.adjusted { border-color: var(--accent-color); background: var(--bg-tertiary); }
    .auto-read select:disabled, .auto-read button:disabled { opacity: 0.4; cursor: not-allowed; }

    /* Book info button (?) */
    .book-info-btn {
      position: relative;
      background: none;
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      min-width: 28px;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .book-info-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .book-info-popup {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 8px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 280px;
      max-width: 400px;
      box-shadow: 0 4px 12px var(--modal-shadow);
      z-index: 1000;
      display: none;
      text-align: left;
    }
    .book-info-btn:hover .book-info-popup,
    .book-info-btn:focus .book-info-popup,
    .book-info-btn.active .book-info-popup {
      display: block;
    }
    .book-info-popup .book-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      line-height: 1.3;
    }
    .book-info-popup .book-author {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-style: italic;
    }
    .book-info-popup .book-author:not(:empty)::before {
      content: "by ";
    }

    /* Progress display in header */
    .header-progress {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .header-percent {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
      min-width: 42px;
      text-align: right;
    }

    .header-track {
      width: 80px;
      height: 4px;
      background: var(--border-color);
      border-radius: 2px;
      overflow: visible;
    }

    .header-fill {
      height: 100%;
      width: 0%;
      background: var(--accent-color, #3b82f6);
      border-radius: 2px;
      transition: width 0.3s ease-out;
      pointer-events: none;
      position: relative;
    }

    /* Thumb/handle for progress slider */
    .header-fill::after {
      content: '';
      position: absolute;
      right: -4px;
      top: 50%;
      transform: translateY(-50%);
      width: 12px;
      height: 12px;
      background: var(--accent-color, #3b82f6);
      border: 2px solid var(--bg-primary, #fff);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      pointer-events: none;
    }

    /* Interactive progress bar slider */
    .header-track {
      cursor: pointer;
      position: relative;
    }
    .header-track:hover {
      background: var(--border-color);
    }
    .header-track:active,
    .header-track.dragging {
      cursor: grabbing;
    }
    .header-track::after {
      content: '';
      position: absolute;
      top: -8px;
      bottom: -8px;
      left: 0;
      right: 0;
    }

    /* 3D mode controls - inline in header */
    .rope-controls {
      display: none;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: monospace;
      font-size: 12px;
      color: var(--text-muted);
    }

    body.mode-3d .rope-controls {
      display: flex;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .speed-control input[type="range"] {
      width: 80px;
      height: 28px;
      cursor: pointer;
      accent-color: var(--accent-color);
    }

    .speed-control .speed-value {
      min-width: 50px;
      text-align: left;
      font-size: 11px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      user-select: none;
      font-size: 12px;
    }

    .checkbox-label input[type="checkbox"] {
      width: 14px;
      height: 14px;
      cursor: pointer;
      accent-color: var(--accent-color);
    }

    .checkbox-label span {
      white-space: nowrap;
    }

    .mode-3d #autoChunkSize,
    .mode-3d #autoInterval {
      pointer-events: none;
      opacity: 0.5;
    }

    /* Overflow menu button */
    .overflow-btn {
      display: none;
      background: transparent;
      border: none;
      font-size: 18px;
      cursor: pointer;
      opacity: 0.6;
      padding: 0;
      width: 32px;
      height: 32px;
      min-width: 32px;
      min-height: 32px;
      align-items: center;
      justify-content: center;
      color: var(--text-primary);
    }
    .overflow-btn:hover { opacity: 1; }

    /* Overflow menu dropdown */
    .overflow-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 200px;
      box-shadow: 0 4px 12px var(--modal-shadow);
      z-index: 1001;
      display: none;
    }
    .overflow-menu.visible {
      display: block;
    }
    .overflow-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      background: none;
      border: none;
      width: 100%;
      text-align: left;
      font-size: 14px;
      color: var(--text-primary);
      cursor: pointer;
      font-family: var(--font-ui);
    }
    .overflow-menu-item:hover {
      background: var(--bg-secondary);
    }
    .overflow-menu-item .icon {
      font-size: 18px;
      width: 24px;
      text-align: center;
    }
    .overflow-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 8px 0;
    }
    .overflow-menu select {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--btn-bg);
      color: var(--text-primary);
      font-size: 13px;
    }

    /* Fix overflow button visibility in themed headers */
    [data-theme="dark"] .overflow-btn,
    [data-theme="scifi"] .overflow-btn {
      color: var(--text-primary);
    }

    /* Fix overflow menu text in themes with dark headers - override header * rule */
    [data-theme="greenfield"] .overflow-menu,
    [data-theme="greenfield"] .overflow-menu *,
    [data-theme="redbrick"] .overflow-menu,
    [data-theme="redbrick"] .overflow-menu *,
    [data-theme="stoneworks"] .overflow-menu,
    [data-theme="stoneworks"] .overflow-menu *,
    [data-theme="midnight"] .overflow-menu,
    [data-theme="midnight"] .overflow-menu *,
    [data-theme="amber"] .overflow-menu,
    [data-theme="amber"] .overflow-menu * {
      color: var(--text-primary);
    }
    [data-theme="greenfield"] .overflow-menu select,
    [data-theme="redbrick"] .overflow-menu select,
    [data-theme="stoneworks"] .overflow-menu select,
    [data-theme="midnight"] .overflow-menu select,
    [data-theme="amber"] .overflow-menu select {
      background: var(--btn-bg);
      border-color: var(--border-color);
      color: var(--text-primary);
    }

    /* Theme select styling */
    .theme-select {
      height: 32px;
      min-height: 32px;
      padding: 0 6px;
      font-size: 13px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--btn-bg);
      color: var(--text-primary);
      cursor: pointer;
      transition: background-color 0.15s, border-color 0.15s;
    }
    .theme-select.compact {
      min-width: 38px;
      text-align: center;
    }
    .theme-select:hover { background: var(--btn-hover); }
    .theme-select:focus { outline: 2px solid var(--accent-color); outline-offset: 1px; }

    /* Responsive: Show overflow menu and hide collapsible items */
    @media (max-width: 900px) {
      .nav-collapsible {
        display: none;
      }
      .overflow-btn {
        display: flex;
      }
      .header-track {
        width: 60px;
      }
      .speed-control input[type="range"] {
        width: 60px;
      }
    }

    /* In 3D mode, always hide inline header controls - use floating panel instead */
    body.mode-3d .rope-controls {
      display: none !important;
    }

    @media (max-width: 600px) {
      .header-progress {
        display: none;
      }
      .auto-read select:not(#autoDirection) {
        display: none;
      }
    }

    /* Floating 3D controls - collapsible pill in corner */
    .floating-3d-controls {
      display: none;
      position: fixed;
      z-index: 100;
      font-family: monospace;
      font-size: 11px;
      transition: opacity 0.2s, transform 0.2s;
    }
    /* Always show in 3D mode */
    body.mode-3d .floating-3d-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    /* Position classes - default bottom-right */
    .floating-3d-controls { bottom: 80px; right: 16px; }
    .floating-3d-controls.pos-top-right { top: 80px; bottom: auto; right: 16px; }
    .floating-3d-controls.pos-top-left { top: 80px; bottom: auto; left: 16px; right: auto; align-items: flex-start; }
    .floating-3d-controls.pos-bottom-left { bottom: 80px; left: 16px; right: auto; align-items: flex-start; }
    
    /* Collapsed state - just shows toggle pill */
    .floating-3d-controls .controls-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      user-select: none;
      backdrop-filter: blur(4px);
      font-size: 11px;
      opacity: 0.6;
      transition: opacity 0.2s, background 0.2s;
    }
    .floating-3d-controls .controls-toggle:hover {
      opacity: 1;
      background: rgba(0,0,0,0.7);
    }
    .floating-3d-controls .controls-toggle .toggle-icon {
      font-size: 10px;
      transition: transform 0.2s;
    }
    .floating-3d-controls.expanded .controls-toggle .toggle-icon {
      transform: rotate(180deg);
    }
    
    /* Expanded panel */
    .floating-3d-controls .controls-panel {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
      padding: 12px 14px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      min-width: 160px;
      opacity: 0.85;
      transition: opacity 0.2s;
    }
    .floating-3d-controls .controls-panel:hover {
      opacity: 1;
    }
    .floating-3d-controls.expanded .controls-panel {
      display: flex;
    }
    
    .floating-3d-controls .control-row {
      display: flex;
      align-items: center;
      gap: 8px;
      color: rgba(255,255,255,0.8);
    }
    .floating-3d-controls .control-row label {
      min-width: 42px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(255,255,255,0.5);
    }
    .floating-3d-controls input[type="range"] {
      flex: 1;
      height: 4px;
      accent-color: #4af;
      cursor: pointer;
    }
    .floating-3d-controls .speed-value {
      min-width: 38px;
      text-align: right;
      font-size: 11px;
      color: rgba(255,255,255,0.9);
    }
    .floating-3d-controls .progress-track {
      flex: 1;
      height: 3px;
      background: rgba(255,255,255,0.15);
      border-radius: 2px;
      overflow: visible;
      cursor: pointer;
      position: relative;
    }
    .floating-3d-controls .progress-track:hover {
      background: rgba(255,255,255,0.25);
    }
    .floating-3d-controls .progress-track::after {
      content: '';
      position: absolute;
      top: -8px;
      bottom: -8px;
      left: 0;
      right: 0;
    }
    .floating-3d-controls .progress-fill {
      height: 100%;
      background: #4af;
      transition: width 0.3s;
      pointer-events: none;
      position: relative;
      border-radius: 2px;
    }
    /* Thumb for floating progress */
    .floating-3d-controls .progress-fill::after {
      content: '';
      position: absolute;
      right: -5px;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 10px;
      background: #4af;
      border: 2px solid rgba(30,30,40,0.9);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
      pointer-events: none;
    }
    .floating-3d-controls .checkbox-row {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
    .floating-3d-controls .checkbox-row input {
      accent-color: #4af;
    }
    .floating-3d-controls .checkbox-row span {
      font-size: 10px;
      color: rgba(255,255,255,0.7);
    }
    /* Position selector in panel */
    .floating-3d-controls .position-row {
      display: flex;
      gap: 4px;
      justify-content: flex-end;
      margin-top: 4px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .floating-3d-controls .pos-btn {
      width: 20px;
      height: 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: rgba(255,255,255,0.5);
      cursor: pointer;
      font-size: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .floating-3d-controls .pos-btn:hover {
      background: rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.8);
    }
    .floating-3d-controls .pos-btn.active {
      background: rgba(74,170,255,0.3);
      border-color: #4af;
      color: #4af;
    }

    main {
      flex: 1;
      padding: var(--spacing-lg);
      padding-bottom: 70px;
      max-width: 720px;
      margin: 0 auto;
      width: 100%;
      outline: none;
      /* Prevent text selection while allowing vertical scroll */
      -webkit-touch-callout: none;
    }

    /* Mobile: ensure right margin is respected */
    @media (max-width: 768px) {
      main {
        padding-left: 16px;
        padding-right: 16px;
        max-width: 100%;
        box-sizing: border-box;
      }
    }

    #content { text-align: justify; hyphens: auto; overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; }
    #content.loading { color: var(--text-faint); text-align: center; font-style: italic; }
    #content.error { color: var(--danger-text); text-align: center; }

    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: var(--spacing-sm) var(--spacing-lg);
      border-top: 1px solid var(--border-color);
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-faint);
      text-align: center;
      background: var(--bg-primary);
      z-index: 100;
      transition: bottom 0.2s, background-color 0.3s, border-color 0.3s;
      /* Prevent text selection in footer UI */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .footer-link {
      color: var(--text-muted);
      text-decoration: none;
      transition: color 0.15s;
    }
    .footer-link:hover {
      color: var(--accent-color);
      text-decoration: underline;
    }

    /* Clickable location display in footer */
    .footer-location {
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 3px;
      transition: background-color 0.15s, color 0.15s;
      font-variant-numeric: tabular-nums;
    }
    .footer-location:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    .footer-location.copied {
      background: var(--success-bg);
      color: var(--success-text);
    }

    /* Move footer up when debug panel is open */
    body.debug-open footer {
      bottom: 200px;
    }

    /* Also move nav-hint up when debug panel is open */
    body.debug-open .nav-hint {
      bottom: 260px;
    }

    .nav-hint {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--hint-bg);
      color: var(--hint-text);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: 4px;
      font-family: Georgia, serif;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 200;
      max-width: 90vw;
      text-align: center;
      line-height: 1.4;
    }

    .nav-hint.visible { opacity: 1; }

    /* Theme Selector */
    .theme-select {
      min-height: 32px;
      font-size: 12px;
      font-family: monospace;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--btn-bg);
      color: var(--text-primary);
      cursor: pointer;
      padding: 0 var(--spacing-sm);
      margin-left: 4px;
      transition: background-color 0.15s, border-color 0.15s;
    }

    .theme-select:hover { background: var(--btn-hover); }
    .theme-select:focus { outline: 2px solid var(--accent-color); outline-offset: 1px; }

    /* Fullscreen mode - hide chrome but keep controls working */
    :fullscreen header,
    :fullscreen footer,
    :fullscreen .debug-toggle,
    :fullscreen .mode-indicator,
    :fullscreen .p2p-toggle,
    :fullscreen .p2p-panel {
      display: none !important;
    }
    :fullscreen main {
      padding-top: var(--spacing-lg);
    }
    :fullscreen .nav-hint {
      bottom: 20px;
    }

    /* Teleport flash effect - transparent so UI remains visible */
    .teleport-flash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
    }
    .teleport-flash.active {
      opacity: 0;
    }

    /* Teleport notification modal */
    .teleport-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--modal-bg);
      color: var(--text-primary);
      padding: 24px 48px;
      border-radius: 12px;
      font-family: Georgia, serif;
      font-size: 18px;
      text-align: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease-out;
      box-shadow: 0 4px 24px var(--modal-shadow), 0 0 0 1px var(--border-light);
    }
    .teleport-modal.visible {
      opacity: 1;
    }
    .teleport-modal .teleport-icon {
      font-size: 32px;
      margin-bottom: 12px;
      text-shadow: none;
    }
    .teleport-modal .teleport-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .teleport-modal .teleport-info {
      font-size: 18px;
      max-width: 320px;
      line-height: 1.4;
      color: var(--text-primary);
    }
    .teleport-modal .teleport-info em {
      font-style: italic;
    }
    .teleport-modal .teleport-spinner {
      width: 24px;
      height: 24px;
      margin: 12px auto 0;
      border: 2px solid var(--border-light);
      border-top-color: var(--text-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* End of book confirmation modal */
    .end-of-book-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
    }
    .end-of-book-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    .end-of-book-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 24px 32px;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    .end-of-book-title {
      font-size: 1.3em;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
    }
    .end-of-book-message {
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .end-of-book-question {
      color: var(--text-primary);
      margin-bottom: 20px;
    }
    .end-of-book-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    .end-of-book-btn {
      padding: 10px 24px;
      border-radius: 6px;
      border: none;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }
    .end-of-book-btn:hover {
      transform: translateY(-1px);
    }
    .end-of-book-btn.yes {
      background: var(--accent-color, #4a9eff);
      color: white;
    }
    .end-of-book-btn.yes:hover {
      background: var(--accent-hover, #3a8eef);
    }
    .end-of-book-btn.no {
      background: var(--bg-tertiary, #e0e0e0);
      color: var(--text-primary);
    }
    .end-of-book-btn.no:hover {
      background: var(--border-color, #d0d0d0);
    }

    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      height: 3px;
      background: var(--progress-bar-color, var(--text-primary));
      transition: width 0.2s;
      z-index: 101;
    }

    .debug-toggle {
      position: fixed;
      bottom: 50px;
      right: var(--spacing-lg);
      width: var(--touch-min);
      height: var(--touch-min);
      border-radius: 50%;
      background: var(--btn-bg);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.6;
      transition: opacity 0.2s, bottom 0.2s;
      z-index: 1001;
    }

    .debug-toggle:hover { opacity: 1; }
    .debug-toggle.active { background: #000; color: #fff; opacity: 1; bottom: 220px; }

    .debug-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      max-height: 40vh;
      background: #1a1a1a;
      color: #0f0;
      font-family: monospace;
      font-size: 11px;
      overflow: hidden;
      display: none;
      flex-direction: column;
      z-index: 1000;
    }

    .debug-panel.visible { display: flex; }

    .debug-header {
      padding: var(--spacing-sm) var(--spacing-md);
      background: #000;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: var(--touch-min);
    }

    .debug-tabs { display: flex; gap: 4px; }

    .debug-tab {
      background: #333;
      border: none;
      color: #888;
      padding: var(--spacing-sm) var(--spacing-md);
      min-height: 36px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
    }

    .debug-tab:hover { background: #444; }
    .debug-tab.active { background: #0a0; color: #000; }

    .debug-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .debug-clear {
      background: transparent;
      border: none;
      color: #666;
      font-size: 14px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .debug-clear:hover { color: #f66; }

    .debug-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px 12px;
    }

    .debug-entry {
      padding: 3px 0;
      border-bottom: 1px solid #333;
      display: flex;
      gap: 8px;
      font-size: 11px;
    }

    .debug-entry .time { color: #666; min-width: 70px; }
    .debug-entry .type { min-width: 60px; font-weight: bold; }
    .debug-entry .type.get { color: #0af; }
    .debug-entry .type.init { color: #0f0; }
    .debug-entry .type.chunk { color: #0fa; }
    .debug-entry .type.search { color: #fa0; }
    .debug-entry .type.random { color: #f0a; }
    .debug-entry .type.bookinfo { color: #af0; }
    .debug-entry .type.error { color: #f00; }
    .debug-entry .type.mirror { color: #0ff; }
    .debug-entry .type.mirrors { color: #0ff; }
    .debug-entry .type.mirror_try { color: #888; }
    .debug-entry .type.mirror_success { color: #0f0; }
    .debug-entry .type.mirror_get { color: #0fa; }
    .debug-entry .type.p2p { color: #a0f; }
    .debug-entry .type.p2p_connect { color: #0f0; }
    .debug-entry .type.p2p_disconnect { color: #f60; }
    .debug-entry .type.p2p_peer { color: #0af; }
    .debug-entry .type.p2p_broadcast { color: #fa0; }
    .debug-entry .type.p2p_follow { color: #0fa; }
    .debug-entry .type.p2p_error { color: #f00; }
    .debug-entry .message { color: #ccc; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .debug-entry .duration { color: #666; min-width: 50px; text-align: right; }

    .search-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      z-index: 2000;
    }

    .search-overlay.visible {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 80px;
    }

    .search-panel {
      background: var(--modal-bg);
      color: var(--text-primary);
      width: 90%;
      max-width: 500px;
      border-radius: 8px;
      box-shadow: 0 4px 24px var(--modal-shadow);
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border-color);
    }

    .search-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-light);
      display: flex;
      gap: 8px;
    }

    .search-header input {
      flex: 1;
      padding: 10px 14px;
      font-size: 16px;
      font-family: inherit;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      outline: none;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .search-header input::placeholder { color: var(--text-secondary); }
    .search-header input:focus { border-color: var(--accent-color, var(--text-primary)); }

    .search-lang-select {
      padding: 8px 10px;
      font-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
      min-height: var(--touch-min);
    }
    .search-lang-select:hover { background: var(--btn-hover); }
    .search-lang-select:focus { border-color: var(--accent-color, var(--text-primary)); outline: none; }

    .search-header button {
      padding: 10px 16px;
      font-size: 14px;
      background: var(--btn-bg);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      min-height: var(--touch-min);
    }
    .search-header button:hover { background: var(--btn-hover); }

    .search-results { flex: 1; overflow-y: auto; padding: var(--spacing-sm) 0; }
    .search-results .status { padding: var(--spacing-md); color: var(--text-secondary); font-size: 14px; }
    .search-results ul { list-style: none; }
    .search-results li {
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--border-light);
      cursor: pointer;
      min-height: var(--touch-min);
    }
    .search-results li:hover, .search-results li.selected { background: var(--btn-hover); }
    .search-results .book-id { font-family: monospace; font-size: 12px; color: var(--text-secondary); margin-right: 6px; }
    .search-results .book-title { font-size: 15px; color: var(--text-primary); }
    .search-results .book-meta { font-size: 13px; color: var(--text-secondary); margin-top: 2px; }

    /* Random menu modal */
    .random-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      z-index: 2000;
    }

    .random-overlay.visible {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .random-panel {
      background: var(--bg-primary);
      border-radius: 12px;
      box-shadow: 0 4px 24px var(--modal-shadow);
      padding: 0;
      min-width: 280px;
      max-width: 90vw;
      outline: none;
      transition: background-color 0.3s;
    }

    .random-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-light);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .random-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .random-header button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.5;
      padding: 4px 8px;
    }

    .random-header button:hover { opacity: 1; }

    .random-options {
      padding: 8px 0;
    }

    .random-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      cursor: pointer;
      transition: background 0.15s;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      font-family: inherit;
    }

    .random-option:hover { background: var(--bg-secondary); }
    .random-option:active { background: var(--bg-tertiary); }

    .random-option .icon {
      font-size: 24px;
      width: 36px;
      text-align: center;
    }

    .random-option .text {
      flex: 1;
    }

    .random-option .title {
      font-size: 15px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .random-option .desc {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .random-option kbd {
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 11px;
      font-family: monospace;
      color: var(--text-secondary);
    }

    /* Error modal */
    .error-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1100;
      display: none;
      justify-content: center;
      align-items: center;
    }

    .error-overlay.visible {
      display: flex;
    }

    .error-panel {
      background: var(--bg-primary);
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 24px var(--modal-shadow);
    }

    .error-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-light);
    }

    .error-header h3 {
      margin: 0;
      font-size: 18px;
      color: var(--text-primary);
    }

    .error-header button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.6;
      color: var(--text-primary);
    }

    .error-header button:hover { opacity: 1; }

    .error-content {
      padding: 20px;
    }

    .error-content p {
      margin: 0;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .error-actions {
      padding: 16px 20px;
      border-top: 1px solid var(--border-light);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .error-btn {
      padding: 8px 20px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .error-btn.primary {
      background: var(--accent-color);
      color: var(--bg-primary);
      border-color: var(--accent-color);
    }

    .error-btn:hover {
      opacity: 0.9;
    }

    /* Bookmark modal */
    .bookmark-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      z-index: 2000;
    }

    .bookmark-overlay.visible {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 80px;
    }

    .bookmark-panel {
      background: var(--bg-primary);
      width: 90%;
      max-width: 500px;
      border-radius: 8px;
      box-shadow: 0 4px 24px var(--modal-shadow);
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      transition: background-color 0.3s;
    }

    .bookmark-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-light);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .bookmark-header h3 {
      margin: 0;
      font-size: 18px;
      color: var(--text-primary);
    }

    .bookmark-header button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.6;
    }

    .bookmark-header button:hover { opacity: 1; }

    .bookmark-actions {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-light);
      display: flex;
      gap: 8px;
    }

    .bookmark-actions input {
      flex: 1;
      padding: 8px 12px;
      font-size: 14px;
      font-family: inherit;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      outline: none;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .bookmark-actions input:focus { border-color: var(--accent-color); }

    .bookmark-actions button {
      padding: 8px 16px;
      font-size: 14px;
      background: var(--accent-color);
      color: var(--bg-primary);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      min-height: var(--touch-min);
    }

    .bookmark-actions button:hover { background: var(--accent-hover); }

    .bookmark-list {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-sm) 0;
    }

    .bookmark-list .empty {
      padding: var(--spacing-md) var(--spacing-lg);
      color: var(--text-muted);
      font-size: 14px;
      text-align: center;
    }

    .bookmark-item {
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--border-light);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .bookmark-item:hover { background: var(--bg-secondary); }

    .bookmark-item-current {
      opacity: 0.5;
      background: var(--bg-tertiary);
    }
    .bookmark-item-current .bookmark-item-info {
      cursor: not-allowed;
      pointer-events: none;
    }
    .bookmark-item-current:hover { background: var(--bg-tertiary); }
    .bookmark-item-current .current-tag {
      font-weight: normal;
      font-size: 11px;
      color: var(--text-faint);
    }

    .bookmark-item-info {
      flex: 1;
      cursor: pointer;
      min-width: 0;
    }

    .bookmark-item-name {
      font-weight: 500;
      font-size: 15px;
      margin-bottom: 2px;
      color: var(--text-primary);
    }

    .bookmark-item-meta {
      font-size: 12px;
      color: var(--text-muted);
      font-family: monospace;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .bookmark-item-delete {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      opacity: 0.4;
      padding: 4px 8px;
    }

    .bookmark-item-delete:hover { opacity: 1; color: #c00; }

    .bookmark-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-light);
      padding: 0 16px;
    }
    .bookmark-tab {
      padding: 10px 16px;
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-muted);
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
    }
    .bookmark-tab:hover { color: var(--text-secondary); }
    .bookmark-tab.active { color: var(--text-primary); border-bottom-color: var(--text-primary); font-weight: 500; }

    .history-item {
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--border-light);
      cursor: pointer;
    }
    .history-item:hover { background: var(--bg-secondary); }
    .history-item-time { font-size: 11px; color: var(--text-faint); font-family: monospace; margin-bottom: 2px; }
    .history-item-title { font-weight: 500; font-size: 14px; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--text-primary); }
    .history-item-meta { font-size: 12px; color: var(--text-muted); font-family: monospace; }

    /* ========== P2P Reading Rooms Styles ========== */
    
    .p2p-toggle {
      position: fixed;
      bottom: 50px;
      left: var(--spacing-lg);
      width: var(--touch-min);
      height: var(--touch-min);
      border-radius: 50%;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.6;
      transition: opacity 0.2s, bottom 0.2s, background 0.2s;
      z-index: 1001;
    }
    .p2p-toggle:hover { opacity: 1; }
    .p2p-toggle.connected { background: #4ade80; border-color: #22c55e; opacity: 1; }
    .p2p-toggle.broadcasting { background: #f97316; border-color: #ea580c; opacity: 1; }
    
    .p2p-panel {
      position: fixed;
      bottom: 100px;
      left: var(--spacing-lg);
      width: 320px;
      max-width: calc(100vw - 40px);
      background: var(--modal-bg, #fff);
      border-radius: 12px;
      box-shadow: 0 4px 24px var(--modal-shadow, rgba(0,0,0,0.2));
      z-index: 1002;
      display: none;
      flex-direction: column;
      max-height: 60vh;
    }
    .p2p-panel.visible { display: flex; }
    
    .p2p-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-light, #eee);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .p2p-header h3 { margin: 0; font-size: 16px; font-weight: 600; color: var(--text-primary); }
    .p2p-header button { background: none; border: none; font-size: 18px; cursor: pointer; opacity: 0.5; color: var(--text-primary); }
    .p2p-header button:hover { opacity: 1; }
    
    .p2p-status {
      padding: 12px 16px;
      background: var(--bg-secondary, #f8f8f8);
      border-bottom: 1px solid var(--border-light, #eee);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
    }
    .p2p-status .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }
    .p2p-status .status-dot.connected { background: #22c55e; }
    .p2p-status .status-dot.broadcasting { background: #f97316; animation: pulse 2s infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .p2p-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }
    
    .p2p-section {
      margin-bottom: 20px;
    }
    .p2p-section:last-child { margin-bottom: 0; }
    .p2p-section h4 {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted, #888);
      margin: 0 0 10px 0;
    }
    
    .p2p-input-group {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .p2p-input-group input {
      flex: 1;
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid var(--border-color, #ccc);
      border-radius: 6px;
      font-family: monospace;
      text-transform: uppercase;
      background: var(--bg-primary, #fff);
      color: var(--text-primary);
    }
    .p2p-input-group input:focus { border-color: var(--accent-color, #000); outline: none; }
    .p2p-input-group button {
      padding: 10px 16px;
      font-size: 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .p2p-btn-primary { background: var(--text-primary); color: var(--bg-primary); }
    .p2p-btn-primary:hover { background: var(--text-secondary); }
    .p2p-btn-secondary { background: var(--btn-bg); color: var(--text-primary); border: 1px solid var(--border-color) !important; }
    .p2p-btn-secondary:hover { background: var(--btn-hover); }
    .p2p-btn-danger { background: var(--text-secondary); color: var(--bg-primary); }
    .p2p-btn-danger:hover { opacity: 0.8; }
    
    .p2p-room-code {
      background: var(--bg-secondary, #f8f8f8);
      border: 2px dashed var(--border-color, #ccc);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
      margin-bottom: 12px;
    }
    .p2p-room-code .code {
      font-size: 28px;
      font-family: monospace;
      font-weight: bold;
      letter-spacing: 4px;
      color: var(--text-primary, #000);
      margin-bottom: 8px;
    }
    .p2p-room-code .label {
      font-size: 12px;
      color: var(--text-muted, #666);
    }
    .p2p-room-code .copy-btn {
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      background: var(--btn-bg, #fff);
      border: 1px solid var(--border-color, #ccc);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-primary);
    }
    .p2p-room-code .copy-btn:hover { background: var(--btn-hover, #f0f0f0); }
    
    .p2p-peer-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .p2p-peer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-secondary, #f8f8f8);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 13px;
      color: var(--text-primary);
    }
    .p2p-peer-item:last-child { margin-bottom: 0; }
    .p2p-peer-item .peer-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .p2p-peer-item .peer-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .p2p-peer-item .peer-badge.broadcaster { background: #fed7aa; color: #c2410c; }
    .p2p-peer-item .peer-badge.you { background: #dbeafe; color: #1d4ed8; }
    .p2p-peer-item .follow-btn {
      padding: 4px 10px;
      font-size: 11px;
      border: 1px solid var(--border-color);
      background: var(--btn-bg);
      color: var(--text-primary);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .p2p-peer-item .follow-btn:hover { background: var(--btn-hover); }
    .p2p-peer-item .follow-btn.following { 
      background: var(--success-bg); 
      color: var(--success-text); 
      border-color: var(--success-border); 
    }
    .p2p-peer-item .follow-btn.following:hover { 
      background: var(--danger-bg); 
      color: var(--danger-text); 
      border-color: var(--danger-border); 
    }
    
    /* Multi-stream canvas overlay */
    .p2p-streams-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 50;
      display: none;
    }
    .p2p-streams-container.active { display: block; }
    
    .p2p-stream-pip {
      position: absolute;
      background: rgba(0,0,0,0.9);
      border-radius: 8px;
      overflow: hidden;
      pointer-events: auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: width 0.2s ease, height 0.2s ease;
      touch-action: none; /* Prevent default touch behaviors for dragging */
    }
    .p2p-stream-pip .pip-header {
      background: rgba(255,255,255,0.1);
      padding: 6px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
    }
    .p2p-stream-pip .pip-title {
      font-size: 11px;
      color: #fff;
      font-family: monospace;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-left: 6px;
    }
    .p2p-stream-pip .pip-controls {
      display: flex;
      gap: 2px;
      margin-left: 8px;
    }
    .p2p-stream-pip .pip-collapse,
    .p2p-stream-pip .pip-close {
      background: none;
      border: none;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      padding: 2px 6px;
    }
    .p2p-stream-pip .pip-collapse:hover,
    .p2p-stream-pip .pip-close:hover { color: #fff; }
    .p2p-stream-pip .pip-content {
      padding: 12px;
      color: #fff;
      font-family: Georgia, serif;
      font-size: 14px;
      line-height: 1.5;
      max-height: 200px;
      overflow-y: auto;
    }
    .p2p-stream-pip .pip-footer {
      padding: 4px 10px;
      background: rgba(255,255,255,0.05);
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: flex-end;
      align-items: center;
      font-family: monospace;
      font-size: 10px;
    }
    .p2p-stream-pip .pip-location {
      color: #888;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 3px;
      transition: background-color 0.15s, color 0.15s;
      font-variant-numeric: tabular-nums;
    }
    .p2p-stream-pip .pip-location:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }
    .p2p-stream-pip .pip-location.copied {
      background: rgba(74, 222, 128, 0.3);
      color: #4ade80;
    }
    .p2p-stream-pip canvas {
      display: block;
      width: 100%;
    }
    
    /* Collapsed state - just a discrete bar */
    .p2p-stream-pip.collapsed {
      width: auto !important;
      min-width: 120px;
      max-width: 200px;
    }
    .p2p-stream-pip.collapsed .pip-content,
    .p2p-stream-pip.collapsed .pip-footer,
    .p2p-stream-pip.collapsed canvas {
      display: none !important;
    }
    .p2p-stream-pip.collapsed .pip-header {
      border-radius: 8px;
    }
    .p2p-stream-pip.collapsed .pip-collapse {
      transform: rotate(180deg);
    }

    /* P2P indicator in header */
    .p2p-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 12px;
      background: #f0f0f0;
      color: #666;
    }
    .p2p-indicator.broadcasting { background: #fed7aa; color: #c2410c; }
    .p2p-indicator.following { background: #dbeafe; color: #1d4ed8; }
    .p2p-indicator .indicator-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    /* ========== Responsive Breakpoints ========== */

    /* Tablet and below */
    @media (max-width: 768px) {
      :root {
        --spacing-lg: 16px;
      }

      header {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .auto-read {
        justify-content: center;
      }
    }

    /* Phone */
    @media (max-width: 480px) {
      :root {
        --spacing-lg: 12px;
        --spacing-md: 8px;
      }

      header {
        gap: var(--spacing-sm);
      }

      .nav-buttons {
        order: 5;
      }

      .auto-read select, .auto-read button {
        font-size: 12px;
        padding: 0 6px;
      }

      footer {
        font-size: 11px;
        padding: var(--spacing-sm);
      }

      .search-panel {
        width: 95%;
        max-height: 80vh;
        margin-top: 20px;
      }
      
      /* P2P panel mobile adjustments */
      .p2p-panel {
        width: calc(100vw - 32px);
        left: 16px;
        bottom: 90px;
        max-height: 50vh;
      }
      
      .p2p-toggle {
        bottom: 42px;
        left: 12px;
        width: 38px;
        height: 38px;
        font-size: 14px;
      }
      
      .debug-toggle {
        right: 12px;
        bottom: 42px;
        width: 38px;
        height: 38px;
        font-size: 14px;
      }
      
      /* Mode indicator mobile */
      .mode-indicator {
        bottom: 42px;
        font-size: 10px;
        padding: 5px 12px;
      }
      
      /* Theme select on mobile */
      .theme-select {
        min-height: 36px;
        font-size: 11px;
      }
    }

    /* Landscape phone */
    @media (max-height: 500px) and (orientation: landscape) {
      header {
        padding: var(--spacing-sm);
        gap: var(--spacing-sm);
      }

      .auto-read {
        width: auto;
        order: unset;
      }

      main {
        padding-top: var(--spacing-md);
      }

      .debug-panel {
        max-height: 50vh;
      }

      .debug-toggle.active {
        bottom: calc(50vh + 20px);
      }
    }

    /* Large screens */
    @media (min-width: 1200px) {
      main {
        max-width: 800px;
      }
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .nav-hint,
      .progress-bar,
      .debug-toggle {
        transition: none;
      }
    }

    /* High contrast / dark mode hint for future */
    @media (prefers-color-scheme: dark) {
      /* Can be expanded later */
    }

    /* ========== Mobile Hardening ========== */
    /* Prevent touch zoom and long-press context menus on interactive elements */
    button, a, input, select, .bookmark-item, .history-item, .search-result-item {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    /* Prevent pull-to-refresh and overscroll bouncing */
    html {
      overscroll-behavior: none;
    }

    /* Prevent pinch-zoom on all overlays and modals */
    .bookmark-overlay,
    .search-overlay,
    .error-overlay,
    .random-overlay,
    .end-of-book-overlay,
    .teleport-modal,
    .floating-3d-controls,
    .p2p-panel,
    .overflow-menu {
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    /* Mobile-specific: hide keyboard shortcuts, fix scrolling, hide fullscreen */
    @media (max-width: 768px), (pointer: coarse) {
      /* Prevent any zoom gestures on mobile */
      html, body {
        touch-action: pan-x pan-y;
      }

      /* Main content area - allow vertical scroll only, prevent zoom */
      main {
        touch-action: pan-y;
        user-select: none;
        -webkit-user-select: none;
      }

      /* Allow text selection only in the content div */
      #content {
        user-select: text;
        -webkit-user-select: text;
      }

      /* Hide keyboard shortcuts in footer - not relevant on touch */
      .footer-keyboard-hints {
        display: none !important;
      }

      /* Prevent text selection on buttons during touch */
      button {
        user-select: none;
        -webkit-user-select: none;
      }

      /* Ensure modals are properly positioned for mobile viewport */
      .bookmark-overlay, .search-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      .bookmark-panel, .search-panel {
        max-height: calc(100vh - 120px);
        max-height: calc(100dvh - 120px);
      }

      /* Larger touch targets for bookmark/history items */
      .bookmark-item, .history-item {
        min-height: 48px;
        padding: 12px;
        cursor: pointer;
      }

      .bookmark-item-info {
        cursor: pointer;
      }

      .bookmark-item-delete {
        min-width: 44px;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Footer should be at true bottom */
      footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
      }
    }

    /* iOS-specific: hide fullscreen button (not supported on iOS Safari) */
    @supports (-webkit-touch-callout: none) {
      @media (pointer: coarse) {
        #fullscreenBtn, #overflowFullscreen {
          display: none !important;
        }
      }
    }

    /* JS-applied mobile classes for additional control */
    body.is-ios #fullscreenBtn,
    body.is-ios #overflowFullscreen {
      display: none !important;
    }

    /* Ensure bookmark items are clearly tappable on mobile */
    body.is-mobile .bookmark-item-info,
    body.is-mobile .history-item {
      cursor: pointer;
    }

    /* Mobile: repurpose p2p-toggle and debug-toggle as nav buttons */
    body.is-mobile .p2p-toggle,
    body.is-mobile .debug-toggle,
    body.is-mobile .p2p-toggle.connected,
    body.is-mobile .p2p-toggle.broadcasting {
      font-size: 20px;
      font-family: system-ui, sans-serif;
      background: transparent !important;
      border-color: var(--border-color) !important;
      color: var(--text-primary) !important;
    }

    body.is-mobile .p2p-toggle:disabled,
    body.is-mobile .debug-toggle:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Hide header nav buttons on mobile - now at bottom corners */
    body.is-mobile .nav-buttons {
      display: none;
    }

    /* ========== 3D Rope Mode ========== */
    .canvas-3d {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 50;
      display: none;
      cursor: grab;
      /* Prevent zoom, pan, and selection on canvas */
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    .canvas-3d:active { cursor: grabbing; }
    .canvas-3d.visible { display: block; }

    body.mode-3d header { background: rgba(0,0,0,0.8); border-color: #333; }
    body.mode-3d header, body.mode-3d header * { color: rgba(255,255,255,0.9); }
    body.mode-3d header button, 
    body.mode-3d header select,
    body.mode-3d header #autoChunkSize,
    body.mode-3d header #autoInterval,
    body.mode-3d header #autoDirection { 
      background: rgba(50,50,50,0.9) !important; 
      border-color: rgba(255,255,255,0.3) !important;
      color: #fff !important;
    }
    body.mode-3d header button:hover, 
    body.mode-3d header select:hover { 
      background: rgba(80,80,80,0.9) !important; 
    }
    body.mode-3d .book-info-btn { 
      color: rgba(255,255,255,0.7); 
      border-color: rgba(255,255,255,0.3);
    }
    body.mode-3d .book-info-btn:hover { 
      background: rgba(255,255,255,0.1); 
      color: rgba(255,255,255,0.9);
    }
    body.mode-3d .book-info-popup { 
      background: rgba(20,20,30,0.95); 
      border-color: rgba(255,255,255,0.2);
    }
    body.mode-3d .book-info-popup .book-title { color: rgba(255,255,255,0.9); }
    body.mode-3d .book-info-popup .book-author { color: rgba(255,255,255,0.6); }
    body.mode-3d .header-percent { color: rgba(255,255,255,0.9); }
    body.mode-3d .header-track { background: rgba(255,255,255,0.2); }
    body.mode-3d .header-fill { background: #4af; }
    body.mode-3d .rope-controls { color: rgba(255,255,255,0.7); }
    body.mode-3d .speed-value { color: rgba(255,255,255,0.7); }
    body.mode-3d .checkbox-label { color: rgba(255,255,255,0.7); }
    body.mode-3d .overflow-menu { background: rgba(20,20,30,0.95); border-color: rgba(255,255,255,0.2); }
    body.mode-3d .overflow-menu-item { color: rgba(255,255,255,0.9); }
    body.mode-3d .overflow-menu-item:hover { background: rgba(255,255,255,0.1); }
    body.mode-3d .overflow-menu select { background: rgba(50,50,50,0.9); border-color: rgba(255,255,255,0.3); color: #fff; }
    body.mode-3d footer { background: rgba(0,0,0,0.8); border-color: #333; color: rgba(255,255,255,0.6); }
    body.mode-3d main { display: none; }
    body.mode-3d .progress-bar { 
      background: #4af; 
      height: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    body.mode-3d .teleport-modal { background: rgba(20, 20, 30, 0.95); color: rgba(255,255,255,0.95); }
    body.mode-3d .teleport-modal .teleport-title { color: rgba(150, 180, 255, 0.9); }
    body.mode-3d .teleport-modal .teleport-info { color: rgba(255,255,255,0.95); }
    /* 3D mode: search panel */
    body.mode-3d .search-panel { background: rgba(20,20,30,0.95); border-color: rgba(255,255,255,0.2); }
    body.mode-3d .search-header input { background: rgba(40,40,50,0.9); border-color: rgba(255,255,255,0.3); color: #fff; }
    body.mode-3d .search-header input::placeholder { color: rgba(255,255,255,0.5); }
    body.mode-3d .search-header button { background: rgba(50,50,60,0.9); border-color: rgba(255,255,255,0.3); color: #fff; }
    body.mode-3d .search-header button:hover { background: rgba(70,70,80,0.9); }
    body.mode-3d .search-lang-select { background: rgba(40,40,50,0.9); border-color: rgba(255,255,255,0.3); color: #fff; }
    body.mode-3d .search-lang-select:hover { background: rgba(60,60,70,0.9); }
    body.mode-3d .search-results .status { color: rgba(255,255,255,0.6); }
    body.mode-3d .search-results li { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .search-results li:hover, body.mode-3d .search-results li.selected { background: rgba(255,255,255,0.1); }
    body.mode-3d .search-results .book-id { color: rgba(255,255,255,0.5); }
    body.mode-3d .search-results .book-title { color: rgba(255,255,255,0.9); }
    body.mode-3d .search-results .book-meta { color: rgba(255,255,255,0.6); }
    /* 3D mode: random panel */
    body.mode-3d .random-panel { background: rgba(20,20,30,0.95); }
    body.mode-3d .random-header { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .random-header h3 { color: rgba(255,255,255,0.9); }
    body.mode-3d .random-header button { color: rgba(255,255,255,0.6); }
    body.mode-3d .random-option { border-color: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); }
    body.mode-3d .random-option:hover { background: rgba(255,255,255,0.1); }
    body.mode-3d .random-option .desc { color: rgba(255,255,255,0.6); }
    body.mode-3d .random-option kbd { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.7); }
    /* 3D mode: bookmark panel */
    body.mode-3d .bookmark-panel { background: rgba(20,20,30,0.95); border-color: rgba(255,255,255,0.2); }
    body.mode-3d .bookmark-header { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .bookmark-header h3 { color: rgba(255,255,255,0.9); }
    body.mode-3d .bookmark-header button { color: rgba(255,255,255,0.6); }
    body.mode-3d .bookmark-tabs { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .bookmark-tab { color: rgba(255,255,255,0.6); border-color: transparent; }
    body.mode-3d .bookmark-tab.active { color: rgba(255,255,255,0.9); border-color: rgba(255,255,255,0.5); }
    body.mode-3d .bookmark-actions { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .bookmark-actions input { background: rgba(40,40,50,0.9); border-color: rgba(255,255,255,0.3); color: #fff; }
    body.mode-3d .bookmark-actions input::placeholder { color: rgba(255,255,255,0.5); }
    body.mode-3d .bookmark-actions button { background: #4af; color: #111; }
    body.mode-3d .bookmark-item { border-color: rgba(255,255,255,0.1); }
    body.mode-3d .bookmark-item:hover { background: rgba(255,255,255,0.1); }
    body.mode-3d .bookmark-info .title { color: rgba(255,255,255,0.9); }
    body.mode-3d .bookmark-info .meta { color: rgba(255,255,255,0.6); }
    body.mode-3d .bookmark-list .empty { color: rgba(255,255,255,0.5); }
    /* 3D mode: home confirm and error panels */
    body.mode-3d .error-panel { background: rgba(20,20,30,0.95); border-color: rgba(255,255,255,0.2); }
    body.mode-3d .error-panel h3 { color: rgba(255,255,255,0.9); }
    body.mode-3d .error-panel p { color: rgba(255,255,255,0.7); }
    body.mode-3d .error-panel button { color: rgba(255,255,255,0.6); }
    body.mode-3d .error-btn { background: rgba(50,50,60,0.9); border-color: rgba(255,255,255,0.3); color: #fff !important; }
    body.mode-3d .error-btn:hover { background: rgba(70,70,80,0.9); }

    /* Mode indicator - subtle pill in corner */
    .mode-indicator {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 14px;
      background: rgba(40, 40, 40, 0.85);
      color: rgba(255, 255, 255, 0.9);
      font-family: var(--font-mono);
      font-size: 11px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 102;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
    }
    .mode-indicator.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .mode-indicator::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4ade80;
      animation: pulse-dot 2s ease-in-out infinite;
    }
    .mode-indicator.auto-only::before {
      background: #60a5fa;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.85); }
    }
    .mode-indicator #modeIndicatorCountdown {
      opacity: 0.7;
      font-size: 10px;
    }
    .mode-indicator:hover {
      background: rgba(50, 50, 50, 0.95);
    }
    
    /* Move mode indicator up when debug panel is open */
    body.debug-open .mode-indicator {
      bottom: 255px;
    }

    /* Content fade transitions */
    #content {
      transition: opacity 0.15s ease-out;
    }
    #content.fading {
      opacity: 0.3;
    }

    /* Excerpt mode - minimal display for excerpting */
    body.excerpt-mode {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 40px;
    }
    body.excerpt-mode header,
    body.excerpt-mode footer,
    body.excerpt-mode .debug-toggle,
    body.excerpt-mode .debug-panel,
    body.excerpt-mode .nav-hint,
    body.excerpt-mode .progress-bar,
    body.excerpt-mode .teleport-flash,
    body.excerpt-mode .teleport-modal,
    body.excerpt-mode .canvas-3d,
    body.excerpt-mode .jump-around-indicator,
    body.excerpt-mode .p2p-toggle,
    body.excerpt-mode .p2p-panel,
    body.excerpt-mode .p2p-streams-container,
    body.excerpt-mode .mode-indicator {
      display: none !important;
    }
    body.excerpt-mode main,
    body.excerpt-mode.mode-3d main {
      display: block !important;
      max-width: 640px;
      padding: 0;
      margin: 0 auto;
    }
    body.excerpt-mode #content,
    body.excerpt-mode.mode-3d #content {
      display: block !important;
      font-family: var(--font-body);
      font-size: 22px;
      line-height: 1.7;
      text-align: left;
      color: var(--text-primary);
    }
    body.excerpt-mode .excerpt-excerpt {
      margin-bottom: 24px;
    }
    body.excerpt-mode .excerpt-source {
      font-size: 16px;
      font-family: var(--font-ui);
      color: var(--text-muted);
      font-style: italic;
    }
    body.excerpt-mode .excerpt-source::before {
      content: '';
    }
    body.excerpt-mode .excerpt-cmd {
      position: relative;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-secondary);
      word-break: break-all;
      line-height: 1.5;
      margin-top: 8px;
    }
    body.excerpt-mode .excerpt-cmd:first-of-type {
      margin-top: 48px;
    }
    body.excerpt-mode .excerpt-cmd .copy-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      padding: 4px 10px;
      font-size: 11px;
      font-family: system-ui, sans-serif;
      background: var(--btn-bg);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.15s, color 0.15s, background 0.15s;
      color: var(--text-primary);
    }
    body.excerpt-mode .excerpt-cmd:hover .copy-btn {
      opacity: 1;
    }
    body.excerpt-mode .excerpt-cmd .copy-btn:hover {
      background: var(--btn-hover);
    }
    body.excerpt-mode .excerpt-cmd .copy-btn.copied {
      background: var(--success-bg);
      border-color: var(--success-border);
      color: var(--success-text);
    }

    /* Excerpt mode home link */
    .excerpt-home-link {
      position: fixed;
      bottom: 16px;
      left: 16px;
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-muted);
      text-decoration: none;
      opacity: 0.5;
      transition: opacity 0.15s;
      z-index: 1000;
    }
    .excerpt-home-link:hover {
      opacity: 1;
      color: var(--text-primary);
    }

    /* PIP expand button */
    .p2p-stream-pip .pip-expand {
      background: none;
      border: none;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      padding: 2px 6px;
    }
    .p2p-stream-pip .pip-expand:hover { color: #fff; }

    /* Expanded PIP state - fullscreen overlay */
    .p2p-stream-pip.expanded {
      position: fixed !important;
      top: 60px !important; /* Below global nav (52px + padding) */
      left: 20px !important;
      right: 20px !important;
      bottom: 20px !important;
      width: auto !important;
      height: auto !important;
      z-index: 10000;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
    }
    .p2p-stream-pip.expanded .pip-header {
      flex-shrink: 0;
    }
    .p2p-stream-pip.expanded .pip-content {
      max-height: none;
      flex: 1;
      font-size: 18px;
      line-height: 1.7;
      padding: 20px;
      overflow-y: auto;
    }
    /* 3D mode: content is just book info bar, canvas takes remaining space */
    .p2p-stream-pip.expanded.pip-3d-mode .pip-content {
      flex: 0;
      height: auto;
      padding: 8px 20px;
    }
    .p2p-stream-pip.expanded.pip-3d-mode canvas {
      flex: 1;
      width: 100% !important;
      height: auto !important;
      min-height: 200px;
    }
    .p2p-stream-pip.expanded .pip-expand {
      transform: rotate(180deg);
    }

  </style>
</head>
<body>
  <div class="mode-indicator" id="modeIndicator"><span id="modeIndicatorText">Auto</span><span id="modeIndicatorCountdown"></span></div>
  <div class="progress-bar" id="progress"></div>
  <canvas class="canvas-3d" id="canvas3d" tabindex="-1"></canvas>

  <header>
    <div class="nav-left">
      <button class="search-btn" id="homeBtn" title="Go home"></button>
      <button class="search-btn" id="searchToggle" title="Search (/)"></button>
      <div class="nav-collapsible">
        <button class="search-btn" id="excerptBtn" title="Open excerpt view"></button>
        <button class="search-btn" id="bookmarkBtn" title="Bookmarks (b)"></button>
        <button class="search-btn" id="randomBtn" title="Random menu (r)"></button>
        <button class="search-btn" id="modeToggle" title="Toggle / mode (3)"></button>
        <button class="search-btn" id="fullscreenBtn" title="Toggle fullscreen (z)"></button>
        <select class="theme-select compact" id="themeSelect" title="Theme (Shift+T)">
          <option value="default" title="Default theme"></option>
          <option value="dark" title="Dark theme"></option>
          <option value="scifi" title="Sci-Fi theme"></option>
          <option value="greenfield" title="Greenfield theme"></option>
          <option value="stoneworks" title="Stoneworks theme"></option>
          <option value="redbrick" title="Redbrick theme"></option>
          <option value="midnight" title="Midnight theme"></option>
          <option value="amber" title="Amber theme"></option>
        </select>
      </div>
      <button class="overflow-btn" id="overflowBtn" title="More options"></button>
      <div class="overflow-menu" id="overflowMenu">
        <button class="overflow-menu-item" id="overflowExcerpt"><span class="icon"></span>Excerpt View</button>
        <button class="overflow-menu-item" id="overflowBookmark"><span class="icon"></span>Bookmarks</button>
        <button class="overflow-menu-item" id="overflowRandom"><span class="icon"></span>Random</button>
        <button class="overflow-menu-item" id="overflowMode"><span class="icon"></span>Camera</button>
        <button class="overflow-menu-item" id="overflowP2P"><span class="icon"></span>Reading Rooms</button>
        <button class="overflow-menu-item" id="overflowDebug"><span class="icon"></span>Debug</button>
        <button class="overflow-menu-item" id="overflowFullscreen"><span class="icon"></span>Fullscreen</button>
        <div class="overflow-menu-divider"></div>
        <div class="overflow-menu-item">
          <span class="icon"></span>
          <select id="overflowTheme">
            <option value="default">Default</option>
            <option value="dark">Dark</option>
            <option value="scifi">Sci-Fi</option>
            <option value="greenfield">Greenfield</option>
            <option value="stoneworks">Stoneworks</option>
            <option value="redbrick">Redbrick</option>
            <option value="midnight">Midnight</option>
            <option value="amber">Amber</option>
          </select>
        </div>
        <div class="overflow-menu-item overflow-text-size">
          <span class="icon">Aa</span>
          <select id="overflowTextSize">
            <option value="small">Small text</option>
            <option value="normal" selected>Normal text</option>
            <option value="large">Large text</option>
          </select>
        </div>
      </div>
    </div>
    <div class="nav-center">
      <select class="text-size-select" id="textSizeSelect" title="Text size (Shift+A)">
        <option value="small">A</option>
        <option value="normal" selected>A</option>
        <option value="large">A+</option>
      </select>
      <button class="book-info-btn" id="bookInfoBtn" title="Book info">
        ?
        <div class="book-info-popup" id="bookInfoPopup">
          <div class="book-title" id="titleBarTitle"></div>
          <div class="book-author" id="titleBarAuthor"></div>
        </div>
      </button>
      <div class="header-progress">
        <span class="header-percent" id="percent">%</span>
        <div class="header-track">
          <div class="header-fill" id="progressFill"></div>
        </div>
      </div>
      <div class="rope-controls">
        <div class="speed-control">
          <input type="range" id="speedSlider" min="0" max="100" value="50" title="3D scroll speed">
          <span class="speed-value" id="speedValue">2.6 w/s</span>
        </div>
        <label class="checkbox-label" title="Show connecting line through words">
          <input type="checkbox" id="showThroughLine" checked>
          <span>Line</span>
        </label>
      </div>
    </div>
    <div class="nav-right">
      <div class="nav-buttons">
        <button id="btnBack" title="Back (AS)" disabled></button>
        <button id="btnForward" title="Forward (DW)" disabled></button>
      </div>
      <div class="auto-read">
        <select id="autoChunkSize" title="Words per chunk">
          <option value="1">1w</option>
          <option value="2">2w</option>
          <option value="3">3w</option>
          <option value="5">5w</option>
          <option value="8">8w</option>
          <option value="10">10w</option>
          <option value="50">50w</option>
          <option value="100">100w</option>
          <option value="150">150w</option>
          <option value="175">175w</option>
          <option value="200" selected>200w</option>
          <option value="250">250w</option>
          <option value="300">300w</option>
          <option value="400">400w</option>
          <option value="500">500w</option>
          <option value="custom">Custom...</option>
        </select>
        <select id="autoInterval" title="Seconds between chunks" disabled>
          <option value="2">2s</option>
          <option value="3">3s</option>
          <option value="5">5s</option>
          <option value="10" selected>10s</option>
          <option value="15">15s</option>
        </select>
        <select id="autoDirection" title="Direction" disabled>
          <option value="forward"></option>
          <option value="backward"></option>
        </select>
        <button id="btnAuto" title="Start/stop auto-read"></button>
      </div>
    </div>
  </header>

  <main tabindex="0" id="mainContent">
    <div id="content" class="loading">Loading...</div>
  </main>

  <footer>
    <span id="stats"></span> | <span class="footer-location" id="footerLocation" title="Click to copy location"></span><span class="footer-keyboard-hints"> | Space: auto | /: search | r: random | z: fullscreen | T: theme | 3:  mode | : debug |</span>
    <a href="https://github.com/petethomas/gutex" target="_blank" rel="noopener" class="footer-link" title="View on GitHub"><svg height="14" width="14" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a>
  </footer>

  <div class="nav-hint" id="navHint"></div>
  <div class="teleport-flash" id="teleportFlash"></div>
  <div class="teleport-modal" id="teleportModal">
    <div class="teleport-title">Changing to</div>
    <div class="teleport-info" id="teleportInfo"></div>
    <div class="teleport-spinner"></div>
  </div>

  <!-- End of book confirmation modal -->
  <div class="end-of-book-overlay" id="endOfBookOverlay">
    <div class="end-of-book-modal">
      <div class="end-of-book-title" id="endOfBookTitle">End of Book</div>
      <div class="end-of-book-message" id="endOfBookMessage">You have reached the end of this book.</div>
      <div class="end-of-book-question">Would you like the system to select a new book for you?</div>
      <div class="end-of-book-buttons">
        <button class="end-of-book-btn yes" id="endOfBookYes">Yes, new book</button>
        <button class="end-of-book-btn no" id="endOfBookNo">No, stay here</button>
      </div>
    </div>
  </div>

  <button class="debug-toggle" id="debugToggle" title="Toggle debug panel"></button>

  <div class="debug-panel" id="debugPanel">
    <div class="debug-header">
      <div class="debug-tabs">
        <button class="debug-tab active" data-tab="events">Events</button>
        <button class="debug-tab" data-tab="requests">HTTP</button>
        <button class="debug-tab" data-tab="mirrors">Mirrors</button>
        <button class="debug-tab" data-tab="p2p">P2P</button>
      </div>
      <div class="debug-actions">
        <button class="debug-clear" id="debugClear" title="Clear current tab"></button>
        <span id="debugStatus">Paused</span>
      </div>
    </div>
    <div class="debug-content" id="debugEvents" data-tab="events"></div>
    <div class="debug-content" id="debugRequests" data-tab="requests" style="display:none"></div>
    <div class="debug-content" id="debugMirrors" data-tab="mirrors" style="display:none"></div>
    <div class="debug-content" id="debugP2P" data-tab="p2p" style="display:none"></div>
  </div>

  <div class="search-overlay" id="searchOverlay">
    <div class="search-panel">
      <div class="search-header">
        <input type="text" id="searchQuery" placeholder="Search by title or author...">
        <select id="searchLanguage" class="search-lang-select" title="Search language">
          <option value="en" title="English"> EN</option>
          <option value="de" title="German"> DE</option>
          <option value="fr" title="French"> FR</option>
          <option value="es" title="Spanish"> ES</option>
          <option value="it" title="Italian"> IT</option>
          <option value="pt" title="Portuguese"> PT</option>
          <option value="nl" title="Dutch"> NL</option>
          <option value="fi" title="Finnish"> FI</option>
          <option value="zh" title="Chinese"> ZH</option>
          <option value="ja" title="Japanese"> JA</option>
          <option value="la" title="Latin"> LA</option>
          <option value="el" title="Greek"> EL</option>
          <option value="all" title="All Languages"> All</option>
        </select>
        <button id="searchClose"></button>
      </div>
      <div class="search-results">
        <div class="status" id="searchStatus"></div>
        <ul id="searchResultsList"></ul>
      </div>
    </div>
  </div>

  <div class="random-overlay" id="randomOverlay">
    <div class="random-panel" id="randomPanel" tabindex="-1">
      <div class="random-header">
        <h3>Random</h3>
        <button id="randomClose"></button>
      </div>
      <div class="random-options">
        <button class="random-option" id="randomBookBtn">
          <span class="icon"></span>
          <span class="text">
            <div class="title">Random Book</div>
            <div class="desc">Start a new book from the beginning</div>
          </span>
          <kbd>B</kbd>
        </button>
        <button class="random-option" id="randomLocationBtn">
          <span class="icon"></span>
          <span class="text">
            <div class="title">Random Location</div>
            <div class="desc">Jump to a random spot in a random book</div>
          </span>
          <kbd>L</kbd>
        </button>
        <button class="random-option" id="jumpAroundGlobalBtn">
          <span class="icon"></span>
          <span class="text">
            <div class="title">Jump Around</div>
            <div class="desc">Continuous random jumping across all books</div>
          </span>
          <kbd>J</kbd>
        </button>
        <button class="random-option" id="jumpAroundSameBookBtn">
          <span class="icon"></span>
          <span class="text">
            <div class="title">This Title</div>
            <div class="desc">Continuous random jumping within current book</div>
          </span>
          <kbd>T</kbd>
        </button>
      </div>
    </div>
  </div>

  <!-- Error modal for showing errors to user (e.g., book has no plain text) -->
  <div class="error-overlay" id="errorOverlay">
    <div class="error-panel" id="errorPanel">
      <div class="error-header">
        <h3> Error</h3>
        <button id="errorClose"></button>
      </div>
      <div class="error-content">
        <p id="errorMessage">An error occurred.</p>
      </div>
      <div class="error-actions">
        <button id="errorOkBtn" class="error-btn primary">OK</button>
      </div>
    </div>
  </div>

  <!-- Home confirmation modal -->
  <div class="error-overlay" id="homeConfirmOverlay">
    <div class="error-panel" id="homeConfirmPanel" tabindex="-1">
      <div class="error-header">
        <h3> Go Home?</h3>
        <button id="homeConfirmClose"></button>
      </div>
      <div class="error-content">
        <p>Leave this book and return to the home page? Your current reading position will be lost.</p>
      </div>
      <div class="error-actions">
        <button id="homeConfirmCancel" class="error-btn">Cancel</button>
        <button id="homeConfirmOk" class="error-btn primary">Go Home</button>
      </div>
    </div>
  </div>

  <!-- Bookmark modal -->
  <div class="bookmark-overlay" id="bookmarkOverlay">
    <div class="bookmark-panel" id="bookmarkPanel" tabindex="-1">
      <div class="bookmark-header">
        <h3> Bookmarks</h3>
        <button id="bookmarkClose"></button>
      </div>
      <div class="bookmark-tabs">
        <button class="bookmark-tab active" data-tab="bookmarks">Bookmarks</button>
        <button class="bookmark-tab" data-tab="history">History</button>
      </div>
      <div class="bookmark-actions" id="bookmarkActions">
        <input type="text" id="bookmarkName" placeholder="Bookmark name (optional)">
        <button id="bookmarkSaveBtn">Save</button>
      </div>
      <div class="bookmark-list" id="bookmarkList">
        <div class="empty">No bookmarks yet</div>
      </div>
      <div class="bookmark-list" id="historyList" style="display:none">
        <div class="empty">No history yet</div>
      </div>
    </div>
  </div>

  <!-- Floating 3D controls - collapsible pill -->
  <div class="floating-3d-controls" id="floating3dControls">
    <div class="controls-toggle" id="controlsToggle" title="Camera controls">
      <span></span>
      <span id="floatingPercentCompact">0%</span>
      <span class="toggle-icon"></span>
    </div>
    <div class="controls-panel">
      <div class="control-row">
        <label>Speed</label>
        <input type="range" id="floatingSpeedSlider" min="0" max="100" value="50">
        <span class="speed-value" id="floatingSpeedValue">1.0</span>
      </div>
      <div class="control-row">
        <label>Prog</label>
        <span id="floatingPercent" style="min-width:32px">0%</span>
        <div class="progress-track">
          <div class="progress-fill" id="floatingProgressFill" style="width: 0%"></div>
        </div>
      </div>
      <label class="checkbox-row">
        <input type="checkbox" id="floatingThroughLine" checked>
        <span>Through-line</span>
      </label>
      <div class="position-row" title="Move controls">
        <button class="pos-btn" data-pos="top-left" title="Top left"></button>
        <button class="pos-btn" data-pos="top-right" title="Top right"></button>
        <button class="pos-btn" data-pos="bottom-left" title="Bottom left"></button>
        <button class="pos-btn active" data-pos="bottom-right" title="Bottom right"></button>
      </div>
    </div>
  </div>

  <!-- P2P Reading Rooms Toggle Button -->
  <button class="p2p-toggle" id="p2pToggle" title="Reading Rooms"></button>

  <!-- P2P Control Panel -->
  <div class="p2p-panel" id="p2pPanel">
    <div class="p2p-header">
      <h3> Reading Rooms</h3>
      <button id="p2pClose"></button>
    </div>
    <div class="p2p-status" id="p2pStatus">
      <span class="status-dot" id="p2pStatusDot"></span>
      <span id="p2pStatusText">Not connected</span>
    </div>
    <div class="p2p-content">
      <!-- Display Name (shared between join and create) -->
      <div class="p2p-section" id="p2pNameSection">
        <h4>Your Name</h4>
        <div class="p2p-input-group">
          <input type="text" id="p2pDisplayName" placeholder="Enter your name" style="flex:1">
        </div>
      </div>

      <!-- Join Room Section (visible when not in a room) -->
      <div class="p2p-section" id="p2pJoinSection">
        <h4>Enter a Room Code</h4>
        <div class="p2p-input-group">
          <input type="text" id="p2pRoomCodeInput" placeholder="6-letter code" maxlength="6">
          <button class="p2p-btn-primary" id="p2pJoinBtn">Join</button>
        </div>
      </div>

      <!-- Create Room Section -->
      <div class="p2p-section" id="p2pCreateSection">
        <h4>Or Start a New Room</h4>
        <div class="p2p-input-group">
          <button class="p2p-btn-secondary" id="p2pCreateBtn" style="flex:1">Start a Room</button>
        </div>
      </div>

      <!-- Room Info Section (visible when in a room) -->
      <div class="p2p-section" id="p2pRoomSection" style="display:none">
        <h4>Your Room</h4>
        <div class="p2p-room-code">
          <div class="code" id="p2pRoomCodeDisplay">------</div>
          <div class="label">Share this code so others can join</div>
          <button class="copy-btn" id="p2pCopyCode">Copy Code</button>
        </div>
        <button class="p2p-btn-danger" id="p2pLeaveBtn" style="width:100%">Leave this Room</button>
      </div>

      <!-- Peers Section -->
      <div class="p2p-section" id="p2pPeersSection" style="display:none">
        <h4>People (<span id="p2pPeerCount">0</span>)</h4>
        <ul class="p2p-peer-list" id="p2pPeerList"></ul>
      </div>
    </div>
  </div>

  <!-- P2P Picture-in-Picture streams container -->
  <div class="p2p-streams-container" id="p2pStreamsContainer"></div>

  <script>
function initTheme() {
    const urlParams = new URLSearchParams(window.location.search);
    const urlTheme = urlParams.get('theme');
    const savedTheme = urlTheme || localStorage.getItem('gutex-theme') || 'default';
    applyTheme(savedTheme);
    const select = document.getElementById('themeSelect');
    if (select)
        select.value = savedTheme;
    const savedLanguage = localStorage.getItem('gutex-language') || 'en';
    const searchLangSelect = document.getElementById('searchLanguage');
    if (searchLangSelect)
        searchLangSelect.value = savedLanguage;
    const overflowTheme = document.getElementById('overflowTheme');
    if (overflowTheme)
        overflowTheme.value = savedTheme;
}
function applyTheme(theme) {
    if (theme === 'default') {
        document.documentElement.removeAttribute('data-theme');
    }
    else {
        document.documentElement.setAttribute('data-theme', theme);
    }
    localStorage.setItem('gutex-theme', theme);
    try {
        if (rope3d && rope3d.active) {
            requestAnimationFrame(() => renderRopeFrame());
        }
    }
    catch (e) {
    }
}
const THEMES = ['default', 'dark', 'scifi', 'greenfield', 'stoneworks', 'redbrick', 'midnight', 'amber'];
const THEME_NAMES = {
    'default': 'Default',
    'dark': 'Dark',
    'scifi': 'Sci-Fi',
    'greenfield': 'Greenfield',
    'stoneworks': 'Stoneworks',
    'redbrick': 'Redbrick',
    'midnight': 'Midnight',
    'amber': 'Amber'
};
function cycleTheme() {
    const current = localStorage.getItem('gutex-theme') || 'default';
    const currentIndex = THEMES.indexOf(current);
    const nextIndex = (currentIndex + 1) % THEMES.length;
    const nextTheme = THEMES[nextIndex];
    applyTheme(nextTheme);
    const select = document.getElementById('themeSelect');
    if (select)
        select.value = nextTheme;
    const overflowTheme = document.getElementById('overflowTheme');
    if (overflowTheme)
        overflowTheme.value = nextTheme;
    showHint(`Theme: ${THEME_NAMES[nextTheme]}`, 1000);
}
initTheme();

const TEXT_SIZES = {
    'small': 0.875,
    'normal': 1,
    'large': 1.15
};
const TEXT_SIZE_NAMES = {
    'small': 'Small text',
    'normal': 'Normal text',
    'large': 'Large text'
};
function initTextSize() {
    const savedSize = localStorage.getItem('gutex-text-size') || 'normal';
    applyTextSize(savedSize);
    const select = document.getElementById('textSizeSelect');
    if (select)
        select.value = savedSize;
    const overflowSelect = document.getElementById('overflowTextSize');
    if (overflowSelect)
        overflowSelect.value = savedSize;
}
function applyTextSize(size) {
    const scale = TEXT_SIZES[size] || 1;
    document.documentElement.style.setProperty('--text-scale', String(scale));
    document.body.classList.remove('text-size-small', 'text-size-normal', 'text-size-large');
    document.body.classList.add(`text-size-${size}`);
    localStorage.setItem('gutex-text-size', size);
}
function cycleTextSize() {
    const sizes = Object.keys(TEXT_SIZES);
    const current = localStorage.getItem('gutex-text-size') || 'normal';
    const currentIndex = sizes.indexOf(current);
    const nextIndex = (currentIndex + 1) % sizes.length;
    const nextSize = sizes[nextIndex];
    applyTextSize(nextSize);
    const select = document.getElementById('textSizeSelect');
    if (select)
        select.value = nextSize;
    const overflowSelect = document.getElementById('overflowTextSize');
    if (overflowSelect)
        overflowSelect.value = nextSize;
    showHint(`${TEXT_SIZE_NAMES[nextSize]}`, 1000);
}
initTextSize();

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
if (isMobile) {
    document.body.classList.add('is-mobile');
}
if (isIOS) {
    document.body.classList.add('is-ios');
}
function checkFullscreenSupport() {
    const canFullscreen = document.fullscreenEnabled ||
        document.webkitFullscreenEnabled ||
        document.mozFullScreenEnabled ||
        document.msFullscreenEnabled;
    if (!canFullscreen) {
        const fsBtn = document.getElementById('fullscreenBtn');
        const fsOverflow = document.getElementById('overflowFullscreen');
        if (fsBtn)
            fsBtn.style.display = 'none';
        if (fsOverflow)
            fsOverflow.style.display = 'none';
    }
}
checkFullscreenSupport();
document.addEventListener('gesturestart', function (e) {
    e.preventDefault();
}, { passive: false });
document.addEventListener('gesturechange', function (e) {
    e.preventDefault();
}, { passive: false });
document.addEventListener('gestureend', function (e) {
    e.preventDefault();
}, { passive: false });
let lastTouchCount = 0;
document.addEventListener('touchstart', function (e) {
    lastTouchCount = e.touches.length;
    if (e.touches.length > 1) {
        e.preventDefault();
    }
}, { passive: false });
document.addEventListener('touchmove', function (e) {
    if (e.touches.length > 1) {
        e.preventDefault();
    }
    if (lastTouchCount > 1) {
        e.preventDefault();
    }
}, { passive: false });
if (isMobile) {
    document.addEventListener('contextmenu', function (e) {
        if (e.target.closest('button, .bookmark-item, .history-item, .search-result-item')) {
            e.preventDefault();
        }
    });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300 && e.target.closest('button, a, .bookmark-item, .history-item')) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });
    const p2pBtn = document.getElementById('p2pToggle');
    const debugBtn = document.getElementById('debugToggle');
    if (p2pBtn) {
        p2pBtn.innerHTML = '';
        p2pBtn.title = 'Back';
        p2pBtn.dataset.mobileNav = 'back';
        p2pBtn.disabled = true;
    }
    if (debugBtn) {
        debugBtn.innerHTML = '';
        debugBtn.title = 'Forward';
        debugBtn.dataset.mobileNav = 'forward';
        debugBtn.disabled = true;
    }
}

const state = {
    bookId: null,
    bookTitle: null,
    bookAuthor: null,
    byteStart: 0,
    byteEnd: 0,
    nextByteStart: null,
    docStart: 0,
    docEnd: 0,
    chunkSize: 200,
    loading: false,
    lastFetchDuration: null
};
const autoRead = {
    active: false,
    intervalId: null,
    minInterval: 1000
};
const jumpAround = {
    active: false,
    sameBook: false,
    timeoutId: null,
    countdownId: null,
    nextJumpTime: null,
    interval: 60000
};

function getJumpInterval() {
    const selectedSeconds = parseInt($('autoInterval').value, 10);
    const selectedMs = selectedSeconds * 1000;
    const p90 = latencyTracker.getP90();
    const minSafeMs = p90 + 1000;
    if (selectedMs >= minSafeMs) {
        return selectedMs;
    }
    const adjustedSeconds = Math.ceil(minSafeMs / 1000);
    showHint(`Interval adjusted to ${adjustedSeconds}s (network)`, 1500);
    return minSafeMs;
}
function startJumpAround(sameBookOnly = false) {
    jumpAround.active = true;
    jumpAround.sameBook = sameBookOnly;
    if (sameBookOnly) {
        $('modeIndicatorText').textContent = 'Jumping in book  click to stop';
    }
    else {
        $('modeIndicatorText').textContent = 'Jump Around  click to stop';
    }
    $('modeIndicatorCountdown').textContent = '';
    $('modeIndicator').classList.remove('auto-only');
    $('modeIndicator').classList.add('visible');
    jumpAround.countdownId = setInterval(updateJumpCountdown, 100);
    $('btnBack').disabled = true;
    $('btnForward').disabled = true;
    $('btnAuto').disabled = true;
    $('randomBtn').disabled = true;
    $('autoChunkSize').disabled = false;
    $('autoInterval').disabled = false;
    $('autoDirection').disabled = false;
    $('searchToggle').disabled = true;
    $('excerptBtn').disabled = true;
    $('homeBtn').disabled = true;
    if (rope3d.active) {
        if (!autoRead.active) {
            startAutoRead();
        }
    }
    else {
    }
    if (!sameBookOnly) {
        fadeAndExecute(() => goToRandomLocation());
    }
    scheduleNextJump();
}
function updateJumpCountdown() {
    if (!jumpAround.active || !jumpAround.nextJumpTime) {
        $('modeIndicatorCountdown').textContent = '';
        return;
    }
    const remaining = Math.max(0, jumpAround.nextJumpTime - Date.now());
    const seconds = Math.ceil(remaining / 1000);
    $('modeIndicatorCountdown').textContent = `(${seconds}s)`;
}
async function goToRandomLocationInSameBook() {
    if (!state.bookId)
        return;
    const docStart = state.docStart || 0;
    const docEnd = state.docEnd || 100000;
    const docLength = docEnd - docStart;
    const randomPercent = 0.05 + Math.random() * 0.90;
    const targetByte = Math.floor(docStart + docLength * randomPercent);
    try {
        const data = await fetchChunk(state.bookId, targetByte, state.chunkSize);
        if (!jumpAround.active)
            return;
        if (rope3d.active) {
            fadeCanvas(0.3, 100, () => {
                const newText = data.formattedText || data.words.join(' ');
                const words = tokenizeForRope(newText);
                setRopeWords(words);
                rope3d.wordOffset = 0;
                rope3d.firstByteStart = data.byteStart;
                rope3d.lastByteEnd = data.byteEnd;
                rope3d.viewBytePosition = data.byteStart;
                rope3d.backwardHistory = [];
                rope3d.justToggledFrames = 60;
                if (rope3d.allWords.length > 0) {
                    rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
                }
                fadeCanvas(1, 100);
            });
        }
        else {
            updateUI(data);
        }
        state.byteStart = data.byteStart;
        state.byteEnd = data.byteEnd;
        state.nextByteStart = data.nextByteStart;
        navHistoryStack.length = 0;
        recordNavigation();
    }
    catch (err) {
        console.error('Error jumping in same book:', err);
    }
}
function scheduleNextJump() {
    if (!jumpAround.active)
        return;
    const interval = getJumpInterval();
    jumpAround.nextJumpTime = Date.now() + interval;
    jumpAround.timeoutId = setTimeout(async () => {
        if (!jumpAround.active)
            return;
        if (jumpAround.sameBook) {
            await goToRandomLocationInSameBook();
        }
        else {
            await goToRandomLocation();
        }
        if (jumpAround.active && rope3d.active) {
            if (!autoRead.active) {
                startAutoRead();
            }
        }
        scheduleNextJump();
    }, interval);
}
function stopJumpAround() {
    jumpAround.active = false;
    jumpAround.sameBook = false;
    jumpAround.nextJumpTime = null;
    if (jumpAround.timeoutId) {
        clearTimeout(jumpAround.timeoutId);
        jumpAround.timeoutId = null;
    }
    if (jumpAround.countdownId) {
        clearInterval(jumpAround.countdownId);
        jumpAround.countdownId = null;
    }
    if (!autoRead.active) {
        $('modeIndicator').classList.remove('visible');
    }
    $('modeIndicator').classList.remove('auto-only');
    $('modeIndicatorCountdown').textContent = '';
    if (rope3d.active) {
        rope3d.momentum = 0;
    }
    $('btnBack').disabled = false;
    $('btnForward').disabled = false;
    $('btnAuto').disabled = false;
    $('randomBtn').disabled = false;
    if (!rope3d.active) {
        $('autoChunkSize').disabled = false;
        $('autoInterval').disabled = !autoRead.active;
    }
    $('autoDirection').disabled = false;
    $('searchToggle').disabled = false;
    $('excerptBtn').disabled = false;
    $('homeBtn').disabled = false;
}
function startGlobalJumpAround() {
    closeRandomMenu();
    startJumpAround(false);
}
function startSameBookJumpAround() {
    closeRandomMenu();
    startJumpAround(true);
}
const navHistoryStack = [];
const $ = id => document.getElementById(id);

const latencyTracker = {
    samples: [],
    maxSamples: 5,
    record(ms) {
        this.samples.push(ms);
        if (this.samples.length > this.maxSamples)
            this.samples.shift();
    },
    getAverage() {
        if (this.samples.length === 0)
            return 500;
        return this.samples.reduce((a, b) => a + b, 0) / this.samples.length;
    },
    getP90() {
        if (this.samples.length === 0)
            return 1000;
        const sorted = [...this.samples].sort((a, b) => a - b);
        const idx = Math.floor(sorted.length * 0.9);
        return sorted[Math.min(idx, sorted.length - 1)];
    }
};
function adjustIntervalOptions() {
    const p90 = latencyTracker.getP90();
    const minSafeInterval = Math.ceil(p90 / 1000);
    const select = $('autoInterval');
    let adjusted = false;
    Array.from(select.options).forEach(opt => {
        const val = parseInt(opt.value, 10);
        if (val < minSafeInterval) {
            opt.textContent = opt.textContent.replace(/ \(slow\)$/, '') + ' (slow)';
            adjusted = true;
        }
        else {
            opt.textContent = opt.textContent.replace(/ \(slow\)$/, '');
        }
    });
    select.classList.toggle('adjusted', adjusted);
}

function updateModeIndicator() {
    if (jumpAround.active) {
        return;
    }
    if (autoRead.active) {
        const direction = $('autoDirection').value;
        const directionText = direction === 'forward' ? '' : '';
        $('modeIndicatorText').textContent = `Auto ${directionText}  click to stop`;
        $('modeIndicatorCountdown').textContent = '';
        $('modeIndicator').classList.add('auto-only');
        $('modeIndicator').classList.add('visible');
    }
    else {
        $('modeIndicator').classList.remove('visible');
        $('modeIndicator').classList.remove('auto-only');
    }
}
function fadeAndExecute(callback) {
    const content = $('content');
    content.classList.add('fading');
    setTimeout(() => {
        callback();
        setTimeout(() => {
            content.classList.remove('fading');
        }, 50);
    }, 150);
}
let canvasFadeOpacity = 1;
function fadeCanvas(targetOpacity, duration, callback) {
    const startOpacity = canvasFadeOpacity;
    const startTime = performance.now();
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        canvasFadeOpacity = startOpacity + (targetOpacity - startOpacity) * progress;
        if (progress < 1) {
            requestAnimationFrame(animate);
        }
        else if (callback) {
            callback();
        }
    }
    requestAnimationFrame(animate);
}
function stopAutoRead() {
    autoRead.active = false;
    if (autoRead.intervalId) {
        clearInterval(autoRead.intervalId);
        autoRead.intervalId = null;
    }
    $('btnAuto').classList.remove('active');
    $('btnAuto').textContent = '';
    updateButtonStates();
    if (!jumpAround.active) {
        $('modeIndicator').classList.remove('visible');
        $('modeIndicator').classList.remove('auto-only');
    }
}
function syncAutoReadUI() {
    const shouldShowStop = autoRead.active;
    const buttonText = $('btnAuto').textContent;
    if (shouldShowStop && buttonText !== '') {
        console.warn('Auto-read state mismatch: active=true but button shows auto icon. Fixing...');
        $('btnAuto').classList.add('active');
        $('btnAuto').textContent = '';
    }
    else if (!shouldShowStop && buttonText !== '') {
        console.warn('Auto-read state mismatch: active=false but button shows stop icon. Fixing...');
        $('btnAuto').classList.remove('active');
        $('btnAuto').textContent = '';
        if (autoRead.intervalId) {
            clearInterval(autoRead.intervalId);
            autoRead.intervalId = null;
        }
    }
}
function startAutoRead() {
    autoRead.active = true;
    $('btnAuto').classList.add('active');
    $('btnAuto').textContent = '';
    updateButtonStates();
    if (!jumpAround.active) {
        updateModeIndicator();
    }
    if (rope3d.active) {
        return;
    }
    const interval = parseInt($('autoInterval').value, 10) * 1000;
    const direction = $('autoDirection').value;
    const chunkSize = parseInt($('autoChunkSize').value, 10);
    if (chunkSize !== state.chunkSize) {
        state.chunkSize = chunkSize;
        initBook(state.bookId, state.byteStart, chunkSize, false, false);
    }
    autoRead.intervalId = setInterval(() => {
        const currentPercent = parseFloat($('percent').textContent) || 0;
        const atEnd = direction === 'forward' && (state.nextByteStart == null || currentPercent >= 99.5);
        const atStart = direction === 'backward' && navHistoryStack.length === 0 && currentPercent <= 0.5;
        if (atEnd || atStart) {
            fadeAndExecute(() => teleportToRandomLocation());
            return;
        }
        navigate(direction);
    }, interval);
}
function restartAutoIfActive() {
    if (!autoRead.active || rope3d.active)
        return;
    clearInterval(autoRead.intervalId);
    const interval = parseInt($('autoInterval').value, 10) * 1000;
    const direction = $('autoDirection').value;
    if (!jumpAround.active) {
        updateModeIndicator();
    }
    autoRead.intervalId = setInterval(() => {
        const currentPercent = parseFloat($('percent').textContent) || 0;
        const atEnd = direction === 'forward' && (state.nextByteStart == null || currentPercent >= 99.5);
        const atStart = direction === 'backward' && navHistoryStack.length === 0 && currentPercent <= 0.5;
        if (atEnd || atStart) {
            fadeAndExecute(() => teleportToRandomLocation());
            return;
        }
        navigate(direction);
    }, interval);
}
function toggleAutoRead() {
    if (autoRead.active) {
        stopAutoRead();
    }
    else {
        startAutoRead();
    }
}

function showBookChangeModal(title, author, autoHide = true) {
    const modal = $('teleportModal');
    let info = '';
    if (title) {
        info = `<em>${escapeHtml(title)}</em>`;
        if (author) {
            info += `  ${escapeHtml(author)}`;
        }
    }
    else {
        info = 'Loading...';
    }
    $('teleportInfo').innerHTML = info;
    modal.classList.add('visible');
    if (autoHide) {
        setTimeout(() => modal.classList.remove('visible'), 500);
    }
    return modal;
}
function hideBookChangeModal() {
    $('teleportModal').classList.remove('visible');
}
function showEndOfBookModal(direction) {
    const overlay = $('endOfBookOverlay');
    const title = $('endOfBookTitle');
    const message = $('endOfBookMessage');
    if (direction === 'forward') {
        title.textContent = 'End of Book';
        message.textContent = 'You have reached the end of this book.';
    }
    else {
        title.textContent = 'Beginning of Book';
        message.textContent = 'You have reached the beginning of this book.';
    }
    overlay.classList.add('visible');
    $('endOfBookNo').focus();
}
function hideEndOfBookModal() {
    $('endOfBookOverlay').classList.remove('visible');
}
function isAutoModeActive() {
    return autoRead.active || jumpAround.active;
}
async function fetchBookInfo(bookId) {
    try {
        const res = await fetch(`/api/bookinfo/${bookId}`);
        const data = await res.json();
        const parts = [];
        if (data.title) {
            state.bookTitle = data.title;
            parts.push(`<span class="title">${escapeHtml(data.title)}</span>`);
        }
        if (data.author) {
            const formatted = data.author
                .replace(/,\s*\d{4}-\d{4}/g, '')
                .replace(/,\s*\d{4}-/g, '')
                .replace(/,\s*-\d{4}/g, '')
                .replace(/\s*\[.*?\]/g, '')
                .split('; ')
                .map(name => name.split(', ').reverse().join(' ').trim())
                .join(', ');
            state.bookAuthor = formatted;
            parts.push(`<span class="author">by ${escapeHtml(formatted)}</span>`);
        }
        $('titleBarTitle').textContent = state.bookTitle || `Book ${state.bookId}`;
        $('titleBarAuthor').textContent = state.bookAuthor || '';
        const modal = $('teleportModal');
        if (modal.classList.contains('visible') && state.bookTitle) {
            let info = `<em>${escapeHtml(state.bookTitle)}</em>`;
            if (state.bookAuthor) {
                info += `  ${escapeHtml(state.bookAuthor)}`;
            }
            $('teleportInfo').innerHTML = info;
        }
        updateDocumentTitle();
    }
    catch (err) { }
}
function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
function tokenizeForRope(text) {
    const tokens = [];
    const chunks = text.split(/\s+/).filter(c => c.length > 0);
    for (const chunk of chunks) {
        let parts = chunk.split(/(||\||(?<=[a-zA-Z])-(?=[a-zA-Z]))/);
        const finalParts = [];
        for (const part of parts) {
            if (!part || part.length === 0)
                continue;
            if (part === '' || part === '' || part === '|' || part === '-') {
                finalParts.push(part);
                continue;
            }
            const subparts = part.split(/(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|(?<=[a-zA-Z][.!?:;]["'""'']*)(?=[A-Z])/);
            for (const sp of subparts) {
                if (sp && sp.length > 0) {
                    finalParts.push(sp);
                }
            }
        }
        tokens.push(...finalParts);
    }
    return tokens;
}
function processItalics(text) {
    let escaped = escapeHtml(text);
    escaped = escaped.replace(/_([^_]+)_/g, '<em>$1</em>');
    return escaped;
}
function getWordItalicInfo(word, prevItalicState) {
    let isItalic = prevItalicState.active;
    let cleanWord = word;
    let startsItalic = false;
    let endsItalic = false;
    if (word.startsWith('_')) {
        cleanWord = cleanWord.substring(1);
        startsItalic = true;
        isItalic = true;
    }
    if (cleanWord.endsWith('_')) {
        cleanWord = cleanWord.substring(0, cleanWord.length - 1);
        endsItalic = true;
    }
    const nextItalicState = {
        active: startsItalic ? !endsItalic : (isItalic && !endsItalic)
    };
    return {
        cleanWord,
        isItalic: isItalic || startsItalic,
        nextState: nextItalicState
    };
}
function processWordsForItalic(words) {
    const cleanWords = [];
    const italicMap = [];
    let italicState = { active: false };
    for (const word of words) {
        const info = getWordItalicInfo(word, italicState);
        cleanWords.push(info.cleanWord);
        italicMap.push(info.isItalic);
        italicState = info.nextState;
    }
    return { cleanWords, italicMap };
}
function setRopeWords(words) {
    const { cleanWords, italicMap } = processWordsForItalic(words);
    rope3d.allWords = cleanWords;
    rope3d.wordItalicMap = italicMap;
}
function appendRopeWords(newWords) {
    const { cleanWords, italicMap } = processWordsForItalic(newWords);
    rope3d.allWords = rope3d.allWords.concat(cleanWords);
    rope3d.wordItalicMap = rope3d.wordItalicMap.concat(italicMap);
}
function prependRopeWords(newWords) {
    const { cleanWords, italicMap } = processWordsForItalic(newWords);
    rope3d.allWords = cleanWords.concat(rope3d.allWords);
    rope3d.wordItalicMap = italicMap.concat(rope3d.wordItalicMap);
}
function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash)
        return null;
    const parts = hash.split(',').map(p => p.trim());
    const bookId = parseInt(parts[0], 10);
    if (isNaN(bookId))
        return null;
    const byteStart = parts[1] ? parseInt(parts[1], 10) : null;
    const chunkSize = parts[2] ? parseInt(parts[2], 10) : 200;
    const mode = parts[3] === '3d' ? '3d' : '2d';
    return {
        bookId,
        byteStart: (byteStart !== null && !isNaN(byteStart)) ? byteStart : null,
        chunkSize: (!isNaN(chunkSize) && chunkSize > 0) ? chunkSize : 200,
        mode
    };
}
function buildHash(bookId, byteStart, chunkSize, is3d) {
    const base = `#${bookId},${byteStart ?? 0},${chunkSize}`;
    return is3d ? `${base},3d` : base;
}
let lastHashUpdate = 0;
const HASH_UPDATE_INTERVAL = 500;
async function loadLastPosition() {
    try {
        const res = await fetch('/api/lastpos');
        if (res.ok) {
            const pos = await res.json();
            return pos;
        }
    }
    catch (e) {
    }
    return null;
}
function updateHash(force = false) {
    const now = Date.now();
    if (!force && now - lastHashUpdate < HASH_UPDATE_INTERVAL) {
        return;
    }
    try {
        const byteStart = state.byteStart ?? 0;
        const newHash = buildHash(state.bookId, byteStart, state.chunkSize, rope3d.active);
        if (window.location.hash !== newHash) {
            window.history.replaceState(null, '', newHash);
            lastHashUpdate = now;
        }
    }
    catch (e) {
    }
}
function updateButtonStates() {
    const inAutoMode = autoRead.active;
    const shouldDisableNav = state.loading || inAutoMode;
    $('btnBack').disabled = shouldDisableNav;
    $('btnForward').disabled = shouldDisableNav;
    $('autoInterval').disabled = !(inAutoMode || jumpAround.active);
    $('autoDirection').disabled = !(inAutoMode || jumpAround.active);
    const mobileBack = $('p2pToggle');
    const mobileForward = $('debugToggle');
    if (mobileBack && mobileBack.dataset.mobileNav === 'back') {
        mobileBack.disabled = $('btnBack').disabled;
    }
    if (mobileForward && mobileForward.dataset.mobileNav === 'forward') {
        mobileForward.disabled = $('btnForward').disabled;
    }
}
function syncChunkSizeDropdown() {
    const select = $('autoChunkSize');
    const options = Array.from(select.options).map(o => parseInt(o.value, 10));
    if (options.includes(state.chunkSize)) {
        select.value = state.chunkSize;
    }
    else {
        const customOpt = select.querySelector('option[data-custom]');
        if (customOpt) {
            customOpt.value = state.chunkSize;
            customOpt.textContent = `${state.chunkSize}w`;
        }
        else {
            const opt = document.createElement('option');
            opt.value = state.chunkSize;
            opt.textContent = `${state.chunkSize}w`;
            opt.setAttribute('data-custom', 'true');
            select.appendChild(opt);
        }
        select.value = state.chunkSize;
    }
}
function updateUI(data) {
    state.bookId = data.bookId;
    state.byteStart = data.byteStart ?? 0;
    state.byteEnd = data.byteEnd ?? 0;
    state.nextByteStart = data.nextByteStart ?? null;
    state.chunkSize = data.chunkSize || state.chunkSize;
    if (data.docStart !== undefined)
        state.docStart = data.docStart;
    if (data.docEnd !== undefined)
        state.docEnd = data.docEnd;
    $('titleBarTitle').textContent = state.bookTitle || `Book ${data.bookId}`;
    $('titleBarAuthor').textContent = state.bookAuthor || '';
    $('percent').textContent = `${data.percent}%`;
    $('progressFill').style.width = `${data.percent}%`;
    $('progress').style.width = `${data.percent}%`;
    $('content').className = '';
    const displayText = data.formattedText || data.words.join(' ');
    $('content').innerHTML = processItalics(displayText).replace(/\n\n/g, '<br><br>');
    $('stats').textContent = `${data.totalBytes.toLocaleString()} bytes | ${state.chunkSize}w`;
    updateFooterLocation();
    updateButtonStates();
    syncChunkSizeDropdown();
    updateDocumentTitle();
    syncAutoReadUI();
    const savedSize = localStorage.getItem('gutex-text-size') || 'normal';
    applyTextSize(savedSize);
    syncRopeWords();
    recordNavigation();
}
function updateFooterLocation() {
    const locationEl = $('footerLocation');
    if (!locationEl || !state.bookId)
        return;
    const currentPosition = rope3d.active
        ? Math.floor(rope3d.viewBytePosition)
        : state.byteStart;
    if (currentPosition !== undefined) {
        locationEl.textContent = `${state.bookId},${currentPosition},${state.chunkSize}`;
        locationEl.title = `Click to copy URL`;
    }
}
function buildLocationUrl() {
    const currentPosition = rope3d.active
        ? Math.floor(rope3d.viewBytePosition)
        : state.byteStart;
    const hash = buildHash(state.bookId, currentPosition, state.chunkSize, rope3d.active);
    return window.location.origin + window.location.pathname + hash;
}
function copyFooterLocation() {
    const locationEl = $('footerLocation');
    if (!locationEl || !state.bookId)
        return;
    const currentPosition = rope3d.active
        ? Math.floor(rope3d.viewBytePosition)
        : state.byteStart;
    if (currentPosition === undefined)
        return;
    const url = buildLocationUrl();
    navigator.clipboard.writeText(url).then(() => {
        locationEl.classList.add('copied');
        const originalText = locationEl.textContent;
        locationEl.textContent = 'Copied!';
        setTimeout(() => {
            locationEl.classList.remove('copied');
            locationEl.textContent = originalText;
        }, 1500);
    }).catch(() => {
        const textarea = document.createElement('textarea');
        textarea.value = url;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        locationEl.classList.add('copied');
        const originalText = locationEl.textContent;
        locationEl.textContent = 'Copied!';
        setTimeout(() => {
            locationEl.classList.remove('copied');
            locationEl.textContent = originalText;
        }, 1500);
    });
}
const footerLocationEl = $('footerLocation');
if (footerLocationEl) {
    footerLocationEl.addEventListener('click', copyFooterLocation);
}
function updateDocumentTitle() {
    const addr = `${state.bookId}/${state.byteStart}${state.byteEnd}/${state.chunkSize}`;
    if (state.bookTitle) {
        const parts = [state.bookTitle];
        if (state.bookAuthor)
            parts.push(state.bookAuthor);
        document.title = `${parts.join('  ')} [${addr}]  Gutex`;
    }
    else {
        document.title = `[${addr}]  Gutex`;
    }
}
function showHint(text, duration = 1000) {
    if (autoRead.active)
        return;
    const hint = $('navHint');
    hint.textContent = text;
    hint.classList.add('visible');
    setTimeout(() => hint.classList.remove('visible'), duration);
}

async function fetchChunk(bookId, byteStart, chunkSize) {
    const params = new URLSearchParams();
    if (chunkSize)
        params.set('chunkSize', chunkSize);
    let url;
    if (byteStart !== null && byteStart !== undefined && !isNaN(byteStart)) {
        params.set('byteStart', byteStart);
        url = `/api/book/${bookId}/chunk?${params}`;
    }
    else {
        url = `/api/book/${bookId}/init?${params}`;
    }
    const startTime = performance.now();
    const res = await fetch(url);
    const duration = performance.now() - startTime;
    latencyTracker.record(duration);
    state.lastFetchDuration = duration;
    adjustIntervalOptions();
    if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data.error || `HTTP ${res.status}`);
    }
    const data = await res.json();
    if (data.error)
        throw new Error(data.error);
    return data;
}
let searchInitiatedLoad = false;
let pendingBookInfo = null;
async function initBook(bookId, byteStart = null, chunkSize = 200, clearHistory = true, updateHash = true) {
    state.loading = true;
    updateButtonStates();
    $('content').className = 'loading';
    $('content').textContent = `Loading book ${bookId}...`;
    if (clearHistory) {
        navHistoryStack.length = 0;
    }
    const isBookChange = bookId !== state.bookId;
    if (isBookChange) {
        if (pendingBookInfo && pendingBookInfo.bookId === bookId) {
            showBookChangeModal(pendingBookInfo.title, pendingBookInfo.author, false);
        }
        else {
            showBookChangeModal(null, null, false);
        }
        pendingBookInfo = null;
        state.bookTitle = null;
        state.bookAuthor = null;
        $('titleBarTitle').textContent = `Book ${bookId}`;
        $('titleBarAuthor').textContent = '';
        fetchBookInfo(bookId);
    }
    try {
        const data = await fetchChunk(bookId, byteStart, chunkSize);
        updateUI(data);
        searchInitiatedLoad = false;
        if (updateHash) {
            const newHash = buildHash(data.bookId, data.byteStart, state.chunkSize, rope3d.active);
            window.history.replaceState(null, '', newHash);
        }
        if (isBookChange) {
            setTimeout(() => {
                hideBookChangeModal();
                state.loading = false;
                updateButtonStates();
            }, 500);
        }
        else {
            state.loading = false;
            updateButtonStates();
        }
        return data;
    }
    catch (err) {
        hideBookChangeModal();
        state.loading = false;
        updateButtonStates();
        if (err.message && err.message.includes('No plain text')) {
            if (searchInitiatedLoad) {
                searchInitiatedLoad = false;
                showErrorModal(`This book is not available in plain text format.\n\nTry searching for a different edition or another book.`);
                openSearch();
            }
            else {
                $('content').className = 'error';
                $('content').textContent = `Error: ${err.message}`;
            }
        }
        else {
            $('content').className = 'error';
            $('content').textContent = `Error: ${err.message}`;
        }
        return null;
    }
}
async function navigate(direction) {
    if (state.loading || !state.bookId)
        return;
    if (direction === 'forward') {
        if (state.nextByteStart == null) {
            if (isAutoModeActive()) {
                teleportToRandomLocation();
            }
            else {
                showEndOfBookModal('forward');
            }
            return;
        }
        state.loading = true;
        try {
            navHistoryStack.push(state.byteStart);
            const data = await fetchChunk(state.bookId, state.nextByteStart, state.chunkSize);
            if (data.actualCount === 0 || (data.words && data.words.length === 0)) {
                navHistoryStack.pop();
                state.loading = false;
                if (isAutoModeActive()) {
                    teleportToRandomLocation();
                }
                else {
                    showEndOfBookModal('forward');
                }
                return;
            }
            updateUI(data);
            showHint('');
        }
        catch (err) {
            navHistoryStack.pop();
            $('content').className = 'error';
            $('content').textContent = `Error: ${err.message}`;
        }
        finally {
            state.loading = false;
            updateButtonStates();
        }
    }
    else {
        const currentPercent = parseFloat($('percent').textContent) || 0;
        const atDocStart = currentPercent <= 0.5 && navHistoryStack.length === 0;
        if (atDocStart) {
            if (isAutoModeActive()) {
                teleportToRandomLocation();
            }
            else {
                showEndOfBookModal('backward');
            }
            return;
        }
        if (navHistoryStack.length === 0) {
            const bytesPerWord = 6;
            const bytesToGoBack = state.chunkSize * bytesPerWord;
            const prevByteStart = Math.max(state.docStart || 0, state.byteStart - bytesToGoBack);
            const minProgress = Math.max(1, Math.floor(bytesToGoBack * 0.5));
            if (prevByteStart >= state.byteStart - minProgress) {
                if (isAutoModeActive()) {
                    teleportToRandomLocation();
                }
                else {
                    showEndOfBookModal('backward');
                }
                return;
            }
            state.loading = true;
            try {
                const data = await fetchChunk(state.bookId, prevByteStart, state.chunkSize);
                if (data.actualCount === 0 || (data.words && data.words.length === 0)) {
                    state.loading = false;
                    if (isAutoModeActive()) {
                        teleportToRandomLocation();
                    }
                    else {
                        showEndOfBookModal('backward');
                    }
                    return;
                }
                const returnedPercent = parseFloat(data.percent) || 0;
                if (returnedPercent <= 0.5) {
                    updateUI(data);
                    showHint(' Start of book');
                    state.loading = false;
                    if (isAutoModeActive()) {
                        setTimeout(() => teleportToRandomLocation(), 500);
                    }
                    else {
                        setTimeout(() => showEndOfBookModal('backward'), 500);
                    }
                    return;
                }
                updateUI(data);
                showHint('');
            }
            catch (err) {
                $('content').className = 'error';
                $('content').textContent = `Error: ${err.message}`;
            }
            finally {
                state.loading = false;
                updateButtonStates();
            }
            return;
        }
        state.loading = true;
        try {
            const prevByteStart = navHistoryStack.pop();
            const data = await fetchChunk(state.bookId, prevByteStart, state.chunkSize);
            if (data.actualCount === 0 || (data.words && data.words.length === 0)) {
                state.loading = false;
                if (isAutoModeActive()) {
                    teleportToRandomLocation();
                }
                else {
                    showEndOfBookModal('backward');
                }
                return;
            }
            updateUI(data);
            showHint('');
        }
        catch (err) {
            $('content').className = 'error';
            $('content').textContent = `Error: ${err.message}`;
        }
        finally {
            state.loading = false;
            updateButtonStates();
        }
    }
}

function openRandomMenu() {
    $('randomOverlay').classList.add('visible');
    $('randomPanel').focus();
}
function closeRandomMenu() {
    $('randomOverlay').classList.remove('visible');
    if (rope3d.active) {
        rope3d.canvas.focus();
    }
    else {
        $('mainContent').focus();
    }
}
async function goToRandomBook() {
    closeRandomMenu();
    state.loading = true;
    updateButtonStates();
    $('content').className = 'loading';
    $('content').textContent = 'Finding a random book...';
    const modal = $('teleportModal');
    const MAX_RETRIES = 10;
    let attempts = 0;
    const lang = $('searchLanguage').value;
    while (attempts < MAX_RETRIES) {
        attempts++;
        try {
            const res = await fetch('/api/random?lang=' + encodeURIComponent(lang));
            const book = await res.json();
            if (book.error)
                throw new Error(book.error);
            showBookChangeModal(book.title, book.author, false);
            const data = await initBook(parseInt(book.id, 10), null, state.chunkSize, true, true);
            if (!data) {
                hideBookChangeModal();
                continue;
            }
            const newHash = buildHash(data.bookId, data.byteStart, state.chunkSize, rope3d.active);
            window.history.replaceState(null, '', newHash);
            if (rope3d.active) {
                state.loading = true;
            }
            if (rope3d.active) {
                fadeCanvas(0.3, 100, () => {
                    const newText = data.formattedText || data.words.join(' ');
                    const words = tokenizeForRope(newText);
                    setRopeWords(words);
                    rope3d.wordOffset = 0;
                    if (!autoRead.active) {
                        rope3d.momentum = 0;
                    }
                    rope3d.firstByteStart = data.byteStart;
                    rope3d.lastByteEnd = data.byteEnd;
                    rope3d.viewBytePosition = data.byteStart;
                    rope3d.backwardHistory = [];
                    rope3d.justToggledFrames = 60;
                    if (rope3d.allWords.length > 0 && data.byteEnd > data.byteStart) {
                        rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
                    }
                    fadeCanvas(1, 100);
                });
                state.loading = false;
            }
            setTimeout(() => {
                modal.classList.remove('visible');
                updateButtonStates();
            }, 500);
            showHint(` ${book.title?.substring(0, 30) || book.id}  from the beginning`);
            return;
        }
        catch (err) {
            if (err.message && err.message.includes('No plain text')) {
                console.log(`Book has no plain text, trying another... (attempt ${attempts})`);
                modal.classList.remove('visible');
                continue;
            }
            modal.classList.remove('visible');
            $('content').className = 'error';
            $('content').textContent = `Error: ${err.message}`;
            state.loading = false;
            updateButtonStates();
            return;
        }
    }
    modal.classList.remove('visible');
    $('content').className = 'error';
    $('content').textContent = 'Could not find a book with plain text after multiple attempts.';
    state.loading = false;
    updateButtonStates();
}
async function goToRandomLocation() {
    closeRandomMenu();
    state.loading = true;
    updateButtonStates();
    $('content').className = 'loading';
    $('content').textContent = 'Finding a random location...';
    const modal = $('teleportModal');
    const MAX_RETRIES = 10;
    let attempts = 0;
    const lang = $('searchLanguage').value;
    while (attempts < MAX_RETRIES) {
        attempts++;
        try {
            const res = await fetch('/api/random?lang=' + encodeURIComponent(lang));
            const book = await res.json();
            if (book.error)
                throw new Error(book.error);
            showBookChangeModal(book.title, book.author, false);
            const randomPercent = Math.floor(Math.random() * 90) + 5;
            const currentChunkSize = state.chunkSize;
            $('content').textContent = `Loading ${book.title?.substring(0, 20) || book.id}...`;
            const initRes = await fetch(`/api/book/${book.id}/init?chunkSize=${currentChunkSize}`);
            const initData = await initRes.json();
            if (initData.error) {
                if (initData.error.includes('No plain text')) {
                    console.log(`Book has no plain text, trying another... (attempt ${attempts})`);
                    modal.classList.remove('visible');
                    continue;
                }
                throw new Error(initData.error);
            }
            const totalCleanBytes = initData.docEnd - initData.docStart;
            const randomByteOffset = Math.floor(totalCleanBytes * (randomPercent / 100));
            const randomByteStart = initData.docStart + randomByteOffset;
            const data = await initBook(parseInt(book.id, 10), randomByteStart, currentChunkSize, true, true);
            if (!data) {
                hideBookChangeModal();
                continue;
            }
            const newHash = buildHash(data.bookId, data.byteStart, currentChunkSize, rope3d.active);
            window.history.replaceState(null, '', newHash);
            if (rope3d.active) {
                state.loading = true;
            }
            if (rope3d.active) {
                fadeCanvas(0.3, 100, () => {
                    const newText = data.formattedText || data.words.join(' ');
                    const words = tokenizeForRope(newText);
                    setRopeWords(words);
                    rope3d.wordOffset = 0;
                    if (!autoRead.active) {
                        rope3d.momentum = 0;
                    }
                    rope3d.firstByteStart = data.byteStart;
                    rope3d.lastByteEnd = data.byteEnd;
                    rope3d.viewBytePosition = data.byteStart;
                    rope3d.backwardHistory = [];
                    rope3d.justToggledFrames = 60;
                    if (rope3d.allWords.length > 0 && data.byteEnd > data.byteStart) {
                        rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
                    }
                    fadeCanvas(1, 100);
                });
                state.loading = false;
            }
            setTimeout(() => {
                modal.classList.remove('visible');
                updateButtonStates();
            }, 500);
            const title = book.title?.substring(0, 25) || `Book ${book.id}`;
            showHint(` ${title} @ ${randomPercent}%`);
            return;
        }
        catch (err) {
            if (err.message && err.message.includes('No plain text')) {
                console.log(`Book has no plain text, trying another... (attempt ${attempts})`);
                modal.classList.remove('visible');
                continue;
            }
            modal.classList.remove('visible');
            $('content').className = 'error';
            $('content').textContent = `Error: ${err.message}`;
            state.loading = false;
            updateButtonStates();
            return;
        }
    }
    modal.classList.remove('visible');
    $('content').className = 'error';
    $('content').textContent = 'Could not find a book with plain text after multiple attempts.';
    state.loading = false;
    updateButtonStates();
}
$('randomClose').addEventListener('click', closeRandomMenu);
$('randomOverlay').addEventListener('click', (e) => {
    if (e.target === $('randomOverlay'))
        closeRandomMenu();
});
$('randomBookBtn').addEventListener('click', goToRandomBook);
$('randomLocationBtn').addEventListener('click', goToRandomLocation);
$('jumpAroundGlobalBtn').addEventListener('click', startGlobalJumpAround);
$('jumpAroundSameBookBtn').addEventListener('click', startSameBookJumpAround);
$('randomPanel').addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (key === 'escape') {
        closeRandomMenu();
        return;
    }
    if (key === 'b') {
        e.preventDefault();
        e.stopPropagation();
        goToRandomBook();
        return;
    }
    if (key === 'l') {
        e.preventDefault();
        e.stopPropagation();
        goToRandomLocation();
        return;
    }
    if (key === 'j') {
        e.preventDefault();
        e.stopPropagation();
        startGlobalJumpAround();
        return;
    }
    if (key === 't') {
        e.preventDefault();
        e.stopPropagation();
        startSameBookJumpAround();
        return;
    }
});

function showErrorModal(message) {
    $('errorMessage').textContent = message;
    $('errorOverlay').classList.add('visible');
    $('errorOkBtn').focus();
}
function closeErrorModal() {
    $('errorOverlay').classList.remove('visible');
    $('mainContent').focus();
}
$('errorClose').addEventListener('click', closeErrorModal);
$('errorOkBtn').addEventListener('click', closeErrorModal);
$('errorOverlay').addEventListener('click', (e) => {
    if (e.target === $('errorOverlay'))
        closeErrorModal();
});
$('errorPanel').addEventListener('keydown', (e) => {
    if (e.key === 'Escape' || e.key === 'Enter') {
        e.preventDefault();
        closeErrorModal();
    }
});
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log('Fullscreen error:', err);
        });
    }
    else {
        document.exitFullscreen();
    }
}
function updateFullscreenIcon() {
    const btn = $('fullscreenBtn');
    if (document.fullscreenElement) {
        btn.textContent = '';
        btn.title = 'Exit fullscreen (z)';
    }
    else {
        btn.textContent = '';
        btn.title = 'Toggle fullscreen (z)';
    }
}
$('fullscreenBtn').addEventListener('click', () => {
    toggleFullscreen();
    refocusAfterButton();
});
document.addEventListener('fullscreenchange', () => {
    updateFullscreenIcon();
    setTimeout(() => {
        resizeRopeCanvas();
        refocusAfterButton();
    }, 100);
});

$('themeSelect').addEventListener('change', (e) => {
    applyTheme(e.target.value);
    $('overflowTheme').value = e.target.value;
    refocusAfterButton();
});
$('textSizeSelect').addEventListener('change', (e) => {
    applyTextSize(e.target.value);
    $('overflowTextSize').value = e.target.value;
    refocusAfterButton();
});
function closeOverflowMenu() {
    $('overflowMenu').classList.remove('visible');
}
$('overflowBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    $('overflowMenu').classList.toggle('visible');
});
document.addEventListener('click', (e) => {
    if (!$('overflowBtn').contains(e.target) && !$('overflowMenu').contains(e.target)) {
        closeOverflowMenu();
    }
});
$('overflowExcerpt').addEventListener('click', () => {
    closeOverflowMenu();
    openExcerptView();
});
$('overflowRandom').addEventListener('click', () => {
    closeOverflowMenu();
    openRandomMenu();
});
$('overflowBookmark').addEventListener('click', () => {
    closeOverflowMenu();
    openBookmarkModal();
});
$('overflowMode').addEventListener('click', () => {
    closeOverflowMenu();
    toggleRopeMode();
});
$('overflowFullscreen').addEventListener('click', () => {
    closeOverflowMenu();
    toggleFullscreen();
});
$('overflowP2P').addEventListener('click', () => {
    closeOverflowMenu();
    toggleP2PPanel();
});
$('overflowDebug').addEventListener('click', () => {
    closeOverflowMenu();
    toggleDebug();
});
$('overflowTheme').addEventListener('change', (e) => {
    $('themeSelect').value = e.target.value;
    applyTheme(e.target.value);
});
$('overflowTextSize').addEventListener('change', (e) => {
    $('textSizeSelect').value = e.target.value;
    applyTextSize(e.target.value);
});
function syncOverflowSelects() {
    $('overflowTheme').value = $('themeSelect').value;
    $('overflowTextSize').value = $('textSizeSelect').value;
}

const BOOKMARKS_KEY = 'gutex_bookmarks';
const navHistory = [];
const MAX_NAV_HISTORY = 100;
function recordNavigation() {
    if (!state.bookId)
        return;
    navHistory.unshift({
        timestamp: Date.now(),
        bookId: state.bookId,
        byteStart: state.byteStart,
        chunkSize: state.chunkSize,
        title: state.bookTitle || `Book ${state.bookId}`,
        percent: $('percent').textContent
    });
    if (navHistory.length > MAX_NAV_HISTORY)
        navHistory.pop();
}
const storage = (function () {
    let memoryStore = {};
    let activeStore = 'memory';
    function testStorage(store) {
        try {
            const test = '__storage_test__';
            store.setItem(test, test);
            store.removeItem(test);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    try {
        if (testStorage(window.localStorage)) {
            activeStore = 'localStorage';
        }
    }
    catch (e) { }
    if (activeStore === 'memory') {
        try {
            if (testStorage(window.sessionStorage)) {
                activeStore = 'sessionStorage';
            }
        }
        catch (e) { }
    }
    return {
        getItem: function (key) {
            try {
                if (activeStore === 'localStorage')
                    return window.localStorage.getItem(key);
                if (activeStore === 'sessionStorage')
                    return window.sessionStorage.getItem(key);
            }
            catch (e) { }
            return memoryStore[key] || null;
        },
        setItem: function (key, value) {
            try {
                if (activeStore === 'localStorage') {
                    window.localStorage.setItem(key, value);
                    return;
                }
                if (activeStore === 'sessionStorage') {
                    window.sessionStorage.setItem(key, value);
                    return;
                }
            }
            catch (e) { }
            memoryStore[key] = value;
        },
        removeItem: function (key) {
            try {
                if (activeStore === 'localStorage') {
                    window.localStorage.removeItem(key);
                    return;
                }
                if (activeStore === 'sessionStorage') {
                    window.sessionStorage.removeItem(key);
                    return;
                }
            }
            catch (e) { }
            delete memoryStore[key];
        },
        type: activeStore
    };
})();
let bookmarksCache = {};
function loadBookmarksFromStorage() {
    try {
        const stored = storage.getItem(BOOKMARKS_KEY);
        if (stored) {
            bookmarksCache = JSON.parse(stored);
        }
    }
    catch (e) {
        console.error('Failed to load bookmarks from storage:', e);
        bookmarksCache = {};
    }
    return bookmarksCache;
}
function loadBookmarks() {
    return bookmarksCache;
}
function saveBookmarkToStorage(name, info) {
    try {
        bookmarksCache[name] = info;
        storage.setItem(BOOKMARKS_KEY, JSON.stringify(bookmarksCache));
    }
    catch (e) {
        console.error('Failed to save bookmark:', e);
    }
}
function deleteBookmarkFromStorage(name) {
    try {
        delete bookmarksCache[name];
        storage.setItem(BOOKMARKS_KEY, JSON.stringify(bookmarksCache));
    }
    catch (e) {
        console.error('Failed to delete bookmark:', e);
    }
}
function renderBookmarkList() {
    const list = $('bookmarkList');
    loadBookmarksFromStorage();
    const bookmarks = loadBookmarks();
    const entries = Object.entries(bookmarks);
    if (entries.length === 0) {
        list.innerHTML = '<div class="empty">No bookmarks yet</div>';
        return;
    }
    entries.sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
    list.innerHTML = entries.map(([name, info], idx) => {
        const displayName = escapeHtml(name);
        const meta = `Book ${info.bookId}  ${info.percent}%`;
        const title = info.bookTitle ? escapeHtml(info.bookTitle.substring(0, 40)) : '';
        const isCurrent = info.bookId === state.bookId &&
            info.byteStart === state.byteStart &&
            info.chunkSize === state.chunkSize;
        const currentClass = isCurrent ? ' bookmark-item-current' : '';
        return `
      <div class="bookmark-item${currentClass}" data-idx="${idx}">
        <div class="bookmark-item-info" data-idx="${idx}">
          <div class="bookmark-item-name">${displayName}${isCurrent ? ' <span class="current-tag">(here)</span>' : ''}</div>
          <div class="bookmark-item-meta">${meta}${title ? '  ' + title : ''}</div>
        </div>
        <button class="bookmark-item-delete" data-idx="${idx}" title="Delete"></button>
      </div>
    `;
    }).join('');
    list._entries = entries;
    list.querySelectorAll('.bookmark-item-info').forEach(el => {
        const idx = parseInt(el.dataset.idx, 10);
        const info = entries[idx][1];
        const isCurrent = info.bookId === state.bookId &&
            info.byteStart === state.byteStart &&
            info.chunkSize === state.chunkSize;
        if (!isCurrent) {
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const name = list._entries[idx][0];
                goToBookmark(name);
            };
            el.addEventListener('click', handler);
            el.addEventListener('touchend', (e) => {
                if (e.cancelable) {
                    handler(e);
                }
            }, { passive: false });
        }
    });
    list.querySelectorAll('.bookmark-item-delete').forEach(el => {
        const handler = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const idx = parseInt(el.dataset.idx, 10);
            const name = list._entries[idx][0];
            deleteBookmark(name);
        };
        el.addEventListener('click', handler);
        el.addEventListener('touchend', (e) => {
            if (e.cancelable) {
                handler(e);
            }
        }, { passive: false });
    });
}
function saveCurrentBookmark() {
    if (!state.bookId)
        return;
    let name = $('bookmarkName').value.trim();
    if (!name) {
        const shortTitle = (state.bookTitle || `Book ${state.bookId}`).substring(0, 20);
        const percent = state.byteStart && state.docEnd
            ? Math.round(((state.byteStart - state.docStart) / (state.docEnd - state.docStart)) * 100)
            : 0;
        const now = new Date();
        const timeStr = now.toLocaleString('en-US', {
            month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
        });
        name = `${shortTitle} @ ${percent}%  ${timeStr}`;
    }
    const info = {
        bookId: state.bookId,
        byteStart: state.byteStart,
        chunkSize: state.chunkSize,
        bookTitle: state.bookTitle,
        bookAuthor: state.bookAuthor,
        percent: state.byteStart && state.docEnd
            ? Math.round(((state.byteStart - state.docStart) / (state.docEnd - state.docStart)) * 100)
            : 0,
        timestamp: Date.now(),
        mode: rope3d.active ? '3d' : '2d'
    };
    saveBookmarkToStorage(name, info);
    $('bookmarkName').value = '';
    renderBookmarkList();
    showHint(`Saved bookmark: ${name}`, 1500);
}
function goToBookmark(name) {
    const bookmarks = loadBookmarks();
    const info = bookmarks[name];
    if (!info)
        return;
    closeBookmarkModal();
    if (info.bookTitle) {
        pendingBookInfo = { bookId: info.bookId, title: info.bookTitle, author: info.bookAuthor || '' };
    }
    const targetMode = info.mode || '2d';
    const needsModeSwitch = (targetMode === '3d') !== rope3d.active;
    if (needsModeSwitch) {
        toggleRopeMode();
    }
    if (rope3d.active) {
        fadeCanvas(0.3, 100);
        const wasAutoActive = autoRead.active;
        initBook(info.bookId, info.byteStart, info.chunkSize).then(data => {
            if (data) {
                const newText = data.formattedText || data.words.join(' ');
                const words = tokenizeForRope(newText);
                setRopeWords(words);
                rope3d.wordOffset = 0;
                rope3d.momentum = 0;
                rope3d.firstByteStart = data.byteStart;
                rope3d.lastByteEnd = data.byteEnd;
                rope3d.viewBytePosition = data.byteStart;
                rope3d.backwardHistory = [];
                rope3d.justToggledFrames = 60;
                if (rope3d.allWords.length > 0 && data.byteEnd > data.byteStart) {
                    rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
                }
            }
            else {
                syncRopeFromContent();
            }
            fadeCanvas(1, 100);
        });
        const newHash = buildHash(info.bookId, info.byteStart, info.chunkSize, true);
        window.history.replaceState(null, '', newHash);
    }
    else {
        const newHash = buildHash(info.bookId, info.byteStart, info.chunkSize, false);
        window.location.hash = newHash;
    }
}
function deleteBookmark(name) {
    deleteBookmarkFromStorage(name);
    renderBookmarkList();
}
function openBookmarkModal() {
    renderBookmarkList();
    renderHistoryList();
    $('bookmarkOverlay').classList.add('visible');
    $('bookmarkPanel').focus();
    $('bookmarkName').focus();
}
function closeBookmarkModal() {
    $('bookmarkOverlay').classList.remove('visible');
    refocusAfterButton();
}
function switchBookmarkTab(tabName) {
    document.querySelectorAll('.bookmark-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
    $('bookmarkList').style.display = tabName === 'bookmarks' ? 'block' : 'none';
    $('historyList').style.display = tabName === 'history' ? 'block' : 'none';
    $('bookmarkActions').style.display = tabName === 'bookmarks' ? 'flex' : 'none';
}
function renderHistoryList() {
    const list = $('historyList');
    if (navHistory.length === 0) {
        list.innerHTML = '<div class="empty">No history yet</div>';
        return;
    }
    list.innerHTML = navHistory.map((h, idx) => {
        const d = new Date(h.timestamp);
        const time = d.toLocaleTimeString();
        const date = d.toLocaleDateString();
        return `
      <div class="history-item" data-idx="${idx}">
        <div class="history-item-time">${date} ${time}</div>
        <div class="history-item-title">${escapeHtml(h.title)}</div>
        <div class="history-item-meta">Book #${h.bookId}  ${h.percent}  ${h.chunkSize}w</div>
      </div>
    `;
    }).join('');
    list.querySelectorAll('.history-item').forEach(el => {
        const handler = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const h = navHistory[parseInt(el.dataset.idx, 10)];
            if (!h)
                return;
            closeBookmarkModal();
            pendingBookInfo = { bookId: h.bookId, title: h.title, author: '' };
            await initBook(h.bookId, h.byteStart, h.chunkSize, true);
        };
        el.addEventListener('click', handler);
        el.addEventListener('touchend', (e) => {
            if (e.cancelable) {
                handler(e);
            }
        }, { passive: false });
    });
}
document.querySelectorAll('.bookmark-tab').forEach(tab => {
    tab.addEventListener('click', () => switchBookmarkTab(tab.dataset.tab));
});
$('bookmarkBtn').addEventListener('click', (e) => {
    e.preventDefault();
    openBookmarkModal();
});
$('bookmarkBtn').addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    openBookmarkModal();
}, { passive: false });
$('bookmarkClose').addEventListener('click', closeBookmarkModal);
$('bookmarkSaveBtn').addEventListener('click', saveCurrentBookmark);
$('bookmarkOverlay').addEventListener('click', (e) => {
    if (e.target === $('bookmarkOverlay'))
        closeBookmarkModal();
});
$('bookmarkPanel').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        e.preventDefault();
        closeBookmarkModal();
    }
    if (e.key === 'Enter' && e.target === $('bookmarkName')) {
        e.preventDefault();
        saveCurrentBookmark();
    }
});
$('endOfBookYes').addEventListener('click', () => {
    hideEndOfBookModal();
    teleportToRandomLocation();
});
$('endOfBookNo').addEventListener('click', () => {
    hideEndOfBookModal();
});
$('endOfBookOverlay').addEventListener('click', (e) => {
    if (e.target === $('endOfBookOverlay'))
        hideEndOfBookModal();
});
$('endOfBookOverlay').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        e.preventDefault();
        hideEndOfBookModal();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT')
        return;
    const key = e.key.toLowerCase();
    const cfg = rope3d.config;
    const randomMenuOpen = $('randomOverlay').classList.contains('visible');
    const bookmarkModalOpen = $('bookmarkOverlay').classList.contains('visible');
    const searchModalOpen = $('searchOverlay')?.classList.contains('visible');
    const modalOpen = randomMenuOpen || bookmarkModalOpen || searchModalOpen;
    switch (e.key) {
        case 'Escape':
            if (jumpAround.active) {
                e.preventDefault();
                stopJumpAround();
                return;
            }
            if (autoRead.active) {
                e.preventDefault();
                stopAutoRead();
                return;
            }
            break;
    }
    if (key === 'j' && !modalOpen) {
        e.preventDefault();
        if (jumpAround.active) {
            stopJumpAround();
        }
        else {
            startJumpAround(true);
        }
        return;
    }
    if (key === '3') {
        e.preventDefault();
        toggleRopeMode();
        return;
    }
    if (key === '2' && rope3d.active) {
        e.preventDefault();
        toggleRopeMode();
        return;
    }
    if (key === 'x') {
        e.preventDefault();
        const dir = $('autoDirection');
        dir.value = dir.value === 'forward' ? 'backward' : 'forward';
        showHint(`Direction: ${dir.value}`, 800);
        if (autoRead.active && !jumpAround.active) {
            updateModeIndicator();
            restartAutoIfActive();
        }
        return;
    }
    if (key === 'r') {
        e.preventDefault();
        openRandomMenu();
        return;
    }
    if (key === 'b') {
        e.preventDefault();
        openBookmarkModal();
        return;
    }
    if (key === 'z') {
        e.preventDefault();
        toggleFullscreen();
        return;
    }
    if (key === 't' && e.shiftKey) {
        e.preventDefault();
        cycleTheme();
        return;
    }
    if (key === 'a' && e.shiftKey && !rope3d.active) {
        e.preventDefault();
        cycleTextSize();
        return;
    }
    if (key === 'v' && rope3d.active) {
        e.preventDefault();
        resetCameraView();
        return;
    }
    if (e.shiftKey && rope3d.active) {
        if (key === 'arrowup' || key === 'w') {
            e.preventDefault();
            rope3d.cameraPitch = Math.max(-cfg.MAX_PITCH, rope3d.cameraPitch - 0.05);
            return;
        }
        if (key === 'arrowdown' || key === 's') {
            e.preventDefault();
            rope3d.cameraPitch = Math.min(cfg.MAX_PITCH, rope3d.cameraPitch + 0.05);
            return;
        }
        if (key === 'arrowleft' || key === 'a') {
            e.preventDefault();
            rope3d.cameraYaw = Math.max(-cfg.MAX_YAW, rope3d.cameraYaw - 0.05);
            return;
        }
        if (key === 'arrowright' || key === 'd') {
            e.preventDefault();
            rope3d.cameraYaw = Math.min(cfg.MAX_YAW, rope3d.cameraYaw + 0.05);
            return;
        }
    }
    if (key === 'arrowup' || key === 'arrowright' || key === 'w' || key === 'd') {
        e.preventDefault();
        if (autoRead.active)
            return;
        if (rope3d.active) {
            rope3d.momentum += getManualMomentum();
        }
        else {
            navigate('forward');
        }
        return;
    }
    if (key === 'arrowdown' || key === 'arrowleft' || key === 's' || key === 'a') {
        e.preventDefault();
        if (autoRead.active)
            return;
        if (rope3d.active) {
            rope3d.momentum -= getManualMomentum();
        }
        else {
            navigate('backward');
        }
        return;
    }
    if (key === 'pagedown') {
        e.preventDefault();
        if (autoRead.active)
            return;
        if (rope3d.active) {
            rope3d.momentum += getManualMomentum() * 5;
        }
        return;
    }
    if (key === 'pageup') {
        e.preventDefault();
        if (autoRead.active)
            return;
        if (rope3d.active) {
            rope3d.momentum -= getManualMomentum() * 5;
        }
        return;
    }
    if (key === ' ') {
        e.preventDefault();
        toggleAutoRead();
        return;
    }
    if (key === '/') {
        e.preventDefault();
        openSearch();
        return;
    }
});
function refocusAfterButton() {
    if (rope3d.active) {
        rope3d.canvas.focus();
    }
    else {
        $('mainContent').focus();
    }
}
function setupHoldToNavigate(btn, direction, blockOtherHandlers = false) {
    let holdInterval = null;
    let holdTimeout = null;
    const HOLD_DELAY = 300;
    const REPEAT_INTERVAL = 150;
    function doNavigate() {
        if (btn.disabled)
            return;
        if (rope3d.active) {
            rope3d.momentum += direction === 'forward' ? getManualMomentum() : -getManualMomentum();
        }
        else {
            navigate(direction);
        }
    }
    function startHold(e) {
        if (btn.disabled)
            return;
        e.preventDefault();
        if (blockOtherHandlers)
            e.stopImmediatePropagation();
        doNavigate();
        holdTimeout = setTimeout(() => {
            holdInterval = setInterval(doNavigate, REPEAT_INTERVAL);
        }, HOLD_DELAY);
    }
    function stopHold(e) {
        if (blockOtherHandlers && e)
            e.stopImmediatePropagation();
        if (holdTimeout) {
            clearTimeout(holdTimeout);
            holdTimeout = null;
        }
        if (holdInterval) {
            clearInterval(holdInterval);
            holdInterval = null;
        }
        refocusAfterButton();
    }
    const captureOpts = blockOtherHandlers ? { capture: true } : false;
    const touchCaptureOpts = blockOtherHandlers ? { capture: true, passive: false } : { passive: false };
    btn.addEventListener('mousedown', startHold, captureOpts);
    btn.addEventListener('touchstart', startHold, touchCaptureOpts);
    btn.addEventListener('mouseup', stopHold, captureOpts);
    btn.addEventListener('mouseleave', stopHold, captureOpts);
    btn.addEventListener('touchend', stopHold, captureOpts);
    btn.addEventListener('touchcancel', stopHold, captureOpts);
    if (blockOtherHandlers) {
        btn.addEventListener('click', (e) => e.stopImmediatePropagation(), { capture: true });
    }
}
setupHoldToNavigate($('btnBack'), 'backward');
setupHoldToNavigate($('btnForward'), 'forward');
const mobileBack = $('p2pToggle');
const mobileForward = $('debugToggle');
if (mobileBack && mobileBack.dataset.mobileNav === 'back') {
    setupHoldToNavigate(mobileBack, 'backward', true);
}
if (mobileForward && mobileForward.dataset.mobileNav === 'forward') {
    setupHoldToNavigate(mobileForward, 'forward', true);
}
$('btnAuto').addEventListener('click', (e) => {
    e.target.blur();
    toggleAutoRead();
    refocusAfterButton();
});
$('randomBtn').addEventListener('click', (e) => {
    e.target.blur();
    openRandomMenu();
});
$('modeIndicator').addEventListener('click', () => {
    if (jumpAround.active) {
        stopJumpAround();
    }
    if (autoRead.active) {
        stopAutoRead();
    }
});
$('titleBarTitle').addEventListener('click', () => {
    if (window.innerWidth > 768)
        return;
    if (state.bookTitle || state.bookAuthor) {
        const parts = [];
        if (state.bookTitle)
            parts.push(state.bookTitle);
        if (state.bookAuthor)
            parts.push(`by ${state.bookAuthor}`);
        showHint(parts.join('  '), 3000);
    }
});
$('mainContent').addEventListener('click', () => $('mainContent').focus());
(function () {
    let wheelAccumulator = 0;
    const WHEEL_THRESHOLD = 150;
    let lastWheelTime = 0;
    const WHEEL_RESET_MS = 300;
    $('mainContent').addEventListener('wheel', (e) => {
        if (rope3d.active)
            return;
        const main = $('mainContent');
        const atTop = main.scrollTop <= 0;
        const atBottom = main.scrollTop + main.clientHeight >= main.scrollHeight - 1;
        const now = Date.now();
        if (now - lastWheelTime > WHEEL_RESET_MS) {
            wheelAccumulator = 0;
        }
        lastWheelTime = now;
        if (e.deltaY > 0 && atBottom) {
            e.preventDefault();
            wheelAccumulator += e.deltaY;
            if (wheelAccumulator >= WHEEL_THRESHOLD) {
                wheelAccumulator = 0;
                navigate('forward');
            }
            return;
        }
        if (e.deltaY < 0 && atTop) {
            e.preventDefault();
            wheelAccumulator += e.deltaY;
            if (wheelAccumulator <= -WHEEL_THRESHOLD) {
                wheelAccumulator = 0;
                navigate('backward');
            }
            return;
        }
        wheelAccumulator = 0;
    }, { passive: false });
})();
const CUSTOM_CHUNK_KEY = 'gutex_custom_chunks';
function loadCustomChunks() {
    try {
        return JSON.parse(localStorage.getItem(CUSTOM_CHUNK_KEY)) || [];
    }
    catch (e) {
        return [];
    }
}
function saveCustomChunk(size) {
    const chunks = loadCustomChunks();
    if (!chunks.includes(size)) {
        chunks.push(size);
        chunks.sort((a, b) => a - b);
        localStorage.setItem(CUSTOM_CHUNK_KEY, JSON.stringify(chunks));
    }
}
function populateCustomChunks() {
    const select = $('autoChunkSize');
    const customOptIdx = Array.from(select.options).findIndex(o => o.value === 'custom');
    if (customOptIdx < 0)
        return;
    const standardVals = ['1', '2', '3', '5', '8', '10', '50', '100', '150', '175', '200', '250', '300', '400', '500'];
    Array.from(select.options).forEach(opt => {
        if (!standardVals.includes(opt.value) && opt.value !== 'custom') {
            opt.remove();
        }
    });
    const customOpt = Array.from(select.options).find(o => o.value === 'custom');
    const customChunks = loadCustomChunks();
    customChunks.forEach(size => {
        if (!standardVals.includes(String(size))) {
            const opt = document.createElement('option');
            opt.value = size;
            opt.textContent = `${size}w `;
            select.insertBefore(opt, customOpt);
        }
    });
}
populateCustomChunks();
$('autoChunkSize').addEventListener('change', (e) => {
    const val = e.target.value;
    if (val === 'custom') {
        const input = prompt('Enter custom chunk size (words):', '225');
        if (input) {
            const size = parseInt(input, 10);
            if (size > 0 && size <= 2000) {
                saveCustomChunk(size);
                populateCustomChunks();
                e.target.value = String(size);
                if (state.bookId) {
                    state.chunkSize = size;
                    if (rope3d.active) {
                        reloadRopeWithChunkSize(size);
                    }
                    else {
                        initBook(state.bookId, state.byteStart, size, false, false);
                    }
                }
            }
            else {
                showHint('Invalid chunk size (1-2000)');
                e.target.value = String(state.chunkSize);
            }
        }
        else {
            e.target.value = String(state.chunkSize);
        }
        refocusAfterButton();
        return;
    }
    e.target.blur();
    if (state.bookId) {
        const newChunkSize = parseInt(val, 10);
        if (newChunkSize !== state.chunkSize) {
            state.chunkSize = newChunkSize;
            if (rope3d.active) {
                reloadRopeWithChunkSize(newChunkSize);
            }
            else {
                initBook(state.bookId, state.byteStart, newChunkSize, false, false);
            }
        }
    }
    refocusAfterButton();
});
$('autoInterval').addEventListener('change', (e) => {
    e.target.blur();
    restartAutoIfActive();
    refocusAfterButton();
});
$('autoDirection').addEventListener('change', (e) => {
    e.target.blur();
    if (autoRead.active && !jumpAround.active) {
        updateModeIndicator();
    }
    restartAutoIfActive();
    refocusAfterButton();
});
window.addEventListener('hashchange', async () => {
    const params = parseHash();
    if (params) {
        const targetMode = params.mode || '2d';
        const wasIn3D = rope3d.active;
        const willBe3D = targetMode === '3d';
        const needsModeSwitch = willBe3D !== wasIn3D;
        if (wasIn3D) {
            fadeCanvas(0.3, 100);
        }
        const data = await initBook(params.bookId, params.byteStart, params.chunkSize);
        if (data && needsModeSwitch) {
            toggleRopeMode();
        }
        if (rope3d.active && data) {
            const newText = data.formattedText || data.words.join(' ');
            const words = tokenizeForRope(newText);
            setRopeWords(words);
            rope3d.wordOffset = 0;
            rope3d.momentum = 0;
            rope3d.firstByteStart = data.byteStart;
            rope3d.lastByteEnd = data.byteEnd;
            rope3d.viewBytePosition = data.byteStart;
            rope3d.backwardHistory = [];
            rope3d.justToggledFrames = 60;
            if (rope3d.allWords.length > 0 && data.byteEnd > data.byteStart) {
                rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
            }
            fadeCanvas(1, 100);
        }
        else if (rope3d.active && !data) {
            syncRopeFromContent();
            fadeCanvas(1, 100);
        }
    }
});

const debug = {
    active: false,
    pollInterval: null,
    currentTab: 'events',
    clearTimestamps: { events: 0, requests: 0, mirrors: 0, p2p: 0 },
    p2pEvents: []
};
function p2pLog(type, message) {
    const entry = {
        timestamp: Date.now(),
        type: type,
        message: message
    };
    debug.p2pEvents.push(entry);
    if (debug.p2pEvents.length > 100) {
        debug.p2pEvents.shift();
    }
    if (debug.active && debug.currentTab === 'p2p') {
        renderP2PDebug();
    }
}
function renderP2PDebug() {
    const filtered = debug.p2pEvents.filter(e => e.timestamp > debug.clearTimestamps.p2p);
    const statusHtml = `
    <div style="background:#1a1a2e;padding:10px 12px;border-bottom:1px solid #333;font-size:12px;">
      <div style="display:flex;gap:20px;flex-wrap:wrap;">
        <span style="color:#888;">Room: <span style="color:${p2p.roomId ? '#4ade80' : '#666'}">${p2p.roomId || 'None'}</span></span>
        <span style="color:#888;">Peers: <span style="color:#0af">${p2p.peers.size}</span></span>
        <span style="color:#888;">WS: <span style="color:${p2p.ws?.readyState === 1 ? '#4ade80' : '#f66'}">${p2p.ws ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][p2p.ws.readyState] : 'NULL'}</span></span>
      </div>
      ${p2p.peers.size > 0 ? `
        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #333;">
          <span style="color:#666;font-size:10px;text-transform:uppercase;">Peers:</span>
          ${Array.from(p2p.peers.values()).map(peer => `
            <span style="display:inline-block;margin:2px 4px;padding:2px 8px;background:#252540;border-radius:10px;font-size:11px;">
              ${escapeHtml(peer.displayName)}${peer.id === p2p.peerId ? ' (you)' : ''}
            </span>
          `).join('')}
        </div>
      ` : ''}
    </div>
  `;
    const eventsHtml = filtered.map(e => {
        const time = new Date(e.timestamp).toLocaleTimeString();
        return `
      <div class="debug-entry">
        <span class="time">${time}</span>
        <span class="type ${e.type}">${e.type.toUpperCase().replace('P2P_', '')}</span>
        <span class="message">${escapeHtml(e.message)}</span>
      </div>
    `;
    }).join('');
    $('debugP2P').innerHTML = statusHtml + (eventsHtml || '<div style="color:#666;padding:20px;">No P2P events yet</div>');
}
function toggleDebug() {
    debug.active = !debug.active;
    $('debugPanel').classList.toggle('visible', debug.active);
    $('debugToggle').classList.toggle('active', debug.active);
    document.body.classList.toggle('debug-open', debug.active);
    $('debugStatus').textContent = debug.active ? 'Live' : 'Paused';
    if (debug.active) {
        pollDebug();
        debug.pollInterval = setInterval(pollDebug, 1000);
    }
    else {
        if (debug.pollInterval) {
            clearInterval(debug.pollInterval);
            debug.pollInterval = null;
        }
    }
}
async function pollDebug() {
    if (!debug.active)
        return;
    try {
        const res = await fetch('/api/debug');
        const data = await res.json();
        if (data.events) {
            const filtered = data.events.filter(e => e.timestamp > debug.clearTimestamps.events);
            const eventsHtml = filtered.map(e => {
                const time = new Date(e.timestamp).toLocaleTimeString();
                const duration = e.duration !== null ? `${Math.round(e.duration)}ms` : '';
                return `
          <div class="debug-entry">
            <span class="time">${time}</span>
            <span class="type ${e.type}">${e.type.toUpperCase()}</span>
            <span class="message">${escapeHtml(e.message)}</span>
            <span class="duration">${duration}</span>
          </div>
        `;
            }).join('');
            $('debugEvents').innerHTML = eventsHtml || '<div style="color:#666;padding:20px;">No events yet</div>';
        }
        if (data.requests) {
            const filtered = data.requests.filter(r => r.timestamp > debug.clearTimestamps.requests);
            const reqHtml = filtered.map(r => {
                const time = new Date(r.timestamp).toLocaleTimeString();
                const bytes = (r.bytes / 1024).toFixed(1);
                const mirrorInfo = r.mirror ? ` via ${r.mirror}` : '';
                return `
          <div class="debug-entry">
            <span class="time">${time}</span>
            <span class="type get">GET</span>
            <span class="message">Book ${r.bookId} bytes ${r.start.toLocaleString()}${r.end.toLocaleString()} (${bytes}KB)${mirrorInfo}</span>
            <span class="duration">${r.duration}ms</span>
          </div>
        `;
            }).join('');
            $('debugRequests').innerHTML = reqHtml || '<div style="color:#666;padding:20px;">No requests yet</div>';
        }
        try {
            const mirrorsRes = await fetch('/api/mirrors');
            const mirrorsData = await mirrorsRes.json();
            if (mirrorsData.mirrors) {
                const mirrorsHtml = mirrorsData.mirrors.map((m, idx) => {
                    const stats = m.stats || {};
                    const total = (stats.successes || 0) + (stats.failures || 0);
                    const successRate = total > 0 ? Math.round((stats.successes / total) * 100) : '-';
                    const avgTime = stats.avgResponseTime ? Math.round(stats.avgResponseTime) + 'ms' : '-';
                    const statusColor = total === 0 ? '#666' : (successRate >= 80 ? '#0f0' : successRate >= 50 ? '#fa0' : '#f00');
                    return `
            <div class="debug-entry">
              <span class="time" style="min-width:30px">#${idx + 1}</span>
              <span class="type" style="color:${statusColor};min-width:40px">${successRate}%</span>
              <span class="message">${escapeHtml(m.provider)} (${escapeHtml(m.location)})</span>
              <span class="duration">${avgTime}</span>
            </div>
          `;
                }).join('');
                $('debugMirrors').innerHTML = `
          <div style="color:#0ff;padding:4px 0;border-bottom:1px solid #333;margin-bottom:4px">
            ${mirrorsData.mirrorCount} mirrors available
          </div>
          ${mirrorsHtml}
        `;
            }
        }
        catch (mirrorErr) {
            $('debugMirrors').innerHTML = '<div style="color:#666;padding:20px;">Could not fetch mirror status</div>';
        }
        renderP2PDebug();
    }
    catch (err) {
    }
}
document.querySelectorAll('.debug-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.debug-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        const tabName = tab.dataset.tab;
        debug.currentTab = tabName;
        document.querySelectorAll('.debug-content').forEach(c => c.style.display = 'none');
        document.querySelector(`.debug-content[data-tab="${tabName}"]`).style.display = 'block';
    });
});
$('debugToggle').addEventListener('click', toggleDebug);
$('debugClear').addEventListener('click', () => {
    const tabName = debug.currentTab;
    debug.clearTimestamps[tabName] = Date.now();
    const content = document.querySelector(`.debug-content[data-tab="${tabName}"]`);
    if (content) {
        content.innerHTML = '<div style="color:#666;padding:20px;">Cleared</div>';
    }
});

const searchState = { results: [], selectedIndex: -1 };
const SEARCH_CACHE_KEY = 'gutex_last_search';
function saveSearchCache(query, results) {
    try {
        storage.setItem(SEARCH_CACHE_KEY, JSON.stringify({ query, results }));
    }
    catch (e) { }
}
function loadSearchCache() {
    try {
        const cached = storage.getItem(SEARCH_CACHE_KEY);
        return cached ? JSON.parse(cached) : null;
    }
    catch (e) {
        return null;
    }
}
function renderSearchResults(results, query) {
    searchState.results = results;
    $('searchStatus').textContent = `${results.length} result${results.length > 1 ? 's' : ''}   Enter`;
    $('searchResultsList').innerHTML = results.map((book, idx) => {
        const author = book.author
            ? book.author.replace(/,\s*\d{4}-\d{4}/g, '').replace(/,\s*\d{4}-/g, '').replace(/,\s*-\d{4}/g, '').replace(/\s*\[.*?\]/g, '').split('; ').map(name => name.split(', ').reverse().join(' ').trim()).join(', ')
            : null;
        return `
      <li data-idx="${idx}" data-id="${book.id}">
        <span class="book-id">#${book.id}</span>
        <span class="book-title">${escapeHtml(book.title)}</span>
        <div class="book-meta">${author ? `<span class="book-author">${escapeHtml(author)}</span>` : ''}</div>
      </li>
    `;
    }).join('');
    $('searchResultsList').querySelectorAll('li').forEach(li => {
        const idx = parseInt(li.dataset.idx, 10);
        const book = searchState.results[idx];
        li.addEventListener('click', () => navigateToResult(li.dataset.id, book?.title, book?.author));
    });
}
function openSearch() {
    $('searchOverlay').classList.add('visible');
    searchState.selectedIndex = -1;
    const cached = loadSearchCache();
    if (cached && cached.results?.length > 0) {
        $('searchQuery').value = cached.query || '';
        renderSearchResults(cached.results, cached.query);
    }
    else {
        $('searchQuery').value = '';
        $('searchStatus').textContent = '';
        $('searchResultsList').innerHTML = '';
        searchState.results = [];
    }
    $('searchQuery').focus();
    $('searchQuery').select();
}
function closeSearch() {
    $('searchOverlay').classList.remove('visible');
    $('mainContent').focus();
}
function updateSearchSelection() {
    const items = $('searchResultsList').querySelectorAll('li');
    items.forEach((item, i) => item.classList.toggle('selected', i === searchState.selectedIndex));
    if (searchState.selectedIndex >= 0 && items[searchState.selectedIndex]) {
        items[searchState.selectedIndex].scrollIntoView({ block: 'nearest' });
    }
}
async function navigateToResult(bookId, title, author) {
    closeSearch();
    searchInitiatedLoad = true;
    if (title) {
        const formattedAuthor = author
            ? author.replace(/,\s*\d{4}-\d{4}/g, '').replace(/,\s*\d{4}-/g, '').replace(/,\s*-\d{4}/g, '').replace(/\s*\[.*?\]/g, '').split('; ').map(name => name.split(', ').reverse().join(' ').trim()).join(', ')
            : '';
        pendingBookInfo = { bookId: parseInt(bookId, 10), title, author: formattedAuthor };
    }
    const wasAutoReading = autoRead.active;
    const hadMomentum = rope3d.active && rope3d.momentum !== 0;
    if (rope3d.active) {
        state.loading = true;
        $('titleBarTitle').textContent = 'Loading...';
        $('titleBarAuthor').textContent = '';
    }
    const data = await initBook(parseInt(bookId, 10), null, state.chunkSize, true);
    if (data) {
        const newHash = buildHash(bookId, data.byteStart, state.chunkSize, rope3d.active);
        window.history.replaceState(null, '', newHash);
    }
    if (rope3d.active && data) {
        const newText = data.formattedText || data.words.join(' ');
        const words = tokenizeForRope(newText);
        setRopeWords(words);
        rope3d.wordOffset = 0;
        if (!wasAutoReading && !hadMomentum) {
            rope3d.momentum = 0;
        }
        rope3d.firstByteStart = data.byteStart;
        rope3d.lastByteEnd = data.byteEnd;
        rope3d.viewBytePosition = data.byteStart;
        rope3d.backwardHistory = [];
        rope3d.justToggledFrames = 60;
        if (rope3d.allWords.length > 0 && data.byteEnd > data.byteStart) {
            rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
        }
        state.loading = false;
    }
}
async function performSearch(query) {
    if (!query || query.length < 2) {
        $('searchStatus').textContent = 'Enter at least 2 characters';
        $('searchResultsList').innerHTML = '';
        searchState.results = [];
        searchState.selectedIndex = -1;
        return;
    }
    $('searchStatus').textContent = 'Searching...';
    $('searchResultsList').innerHTML = '';
    searchState.results = [];
    searchState.selectedIndex = -1;
    try {
        const lang = $('searchLanguage').value;
        const res = await fetch(`/api/search?q=${encodeURIComponent(query)}&lang=${encodeURIComponent(lang)}`);
        const data = await res.json();
        if (data.error) {
            $('searchStatus').textContent = data.error;
            return;
        }
        if (data.results.length === 0) {
            $('searchStatus').textContent = `No results for "${query}"`;
            return;
        }
        renderSearchResults(data.results, query);
        saveSearchCache(query, data.results);
    }
    catch (err) {
        $('searchStatus').textContent = `Error: ${err.message}`;
    }
}
$('searchLanguage').addEventListener('change', (e) => {
    localStorage.setItem('gutex-language', e.target.value);
    const query = $('searchQuery').value;
    if (query && query.length >= 2) {
        performSearch(query);
    }
});
$('searchToggle').addEventListener('click', openSearch);
function openHomeConfirm() {
    $('homeConfirmOverlay').classList.add('visible');
    $('homeConfirmPanel').focus();
}
function closeHomeConfirm() {
    $('homeConfirmOverlay').classList.remove('visible');
    refocusAfterButton();
}
$('homeBtn').addEventListener('click', openHomeConfirm);
$('homeConfirmClose').addEventListener('click', closeHomeConfirm);
$('homeConfirmCancel').addEventListener('click', closeHomeConfirm);
$('homeConfirmOk').addEventListener('click', () => {
    window.location.href = '/';
});
$('homeConfirmOverlay').addEventListener('click', (e) => {
    if (e.target === $('homeConfirmOverlay'))
        closeHomeConfirm();
});
$('homeConfirmPanel').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        e.preventDefault();
        closeHomeConfirm();
    }
    if (e.key === 'Enter') {
        e.preventDefault();
        window.location.href = '/';
    }
});
$('searchClose').addEventListener('click', closeSearch);
$('searchOverlay').addEventListener('click', (e) => { if (e.target === $('searchOverlay'))
    closeSearch(); });
let searchTimeout;
$('searchQuery').addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchState.selectedIndex = -1;
    const query = $('searchQuery').value;
    if (query.length >= 2) {
        searchTimeout = setTimeout(() => performSearch(query), 300);
    }
    else {
        $('searchStatus').textContent = '';
        $('searchResultsList').innerHTML = '';
        searchState.results = [];
    }
});
$('searchQuery').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeSearch();
        return;
    }
    if (e.key === 'Enter') {
        if (searchState.selectedIndex >= 0 && searchState.results[searchState.selectedIndex]) {
            const book = searchState.results[searchState.selectedIndex];
            navigateToResult(book.id, book.title, book.author);
        }
        else {
            performSearch($('searchQuery').value);
        }
        return;
    }
    if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (searchState.results.length > 0) {
            searchState.selectedIndex = Math.min(searchState.selectedIndex + 1, searchState.results.length - 1);
            updateSearchSelection();
        }
        return;
    }
    if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (searchState.results.length > 0) {
            searchState.selectedIndex = Math.max(searchState.selectedIndex - 1, -1);
            updateSearchSelection();
        }
        return;
    }
});

function parseColorToRgb(color) {
    if (color.startsWith('#')) {
        const hex = color.slice(1);
        if (hex.length === 3) {
            return {
                r: parseInt(hex[0] + hex[0], 16),
                g: parseInt(hex[1] + hex[1], 16),
                b: parseInt(hex[2] + hex[2], 16)
            };
        }
        return {
            r: parseInt(hex.slice(0, 2), 16),
            g: parseInt(hex.slice(2, 4), 16),
            b: parseInt(hex.slice(4, 6), 16)
        };
    }
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        return { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) };
    }
    return { r: 0, g: 0, b: 0 };
}

function getContentText() {
    const contentHtml = $('content').innerHTML || '';
    const contentWithSpaces = contentHtml.replace(/<br\s*\/?>/gi, ' ');
    const temp = document.createElement('div');
    temp.innerHTML = contentWithSpaces;
    return temp.textContent || '';
}
const rope3d = {
    active: false,
    canvas: null,
    ctx: null,
    allWords: [],
    wordItalicMap: [],
    wordOffset: 0,
    momentum: 0,
    isDragging: false,
    isRotating: false,
    justToggledFrames: 0,
    lastX: 0,
    lastY: 0,
    lastTime: 0,
    animationId: null,
    lastFrameTime: 0,
    cameraPitch: 0,
    cameraYaw: 0,
    firstByteStart: 0,
    lastByteEnd: 0,
    bytesPerWord: 6,
    viewBytePosition: 0,
    lastWordOffset: 0,
    backwardHistory: [],
    config: {
        WORD_SPACING: 300,
        CURVE_AMPLITUDE_X: 400,
        CURVE_AMPLITUDE_Y: 250,
        CURVE_PERIOD_X: 120,
        CURVE_PERIOD_Y: 90,
        CURVE2_AMPLITUDE_X: 150,
        CURVE2_AMPLITUDE_Y: 100,
        CURVE2_PERIOD_X: 200,
        CURVE2_PERIOD_Y: 160,
        LOOP_AMPLITUDE: 0,
        LOOP_PERIOD: 300,
        LOOP_TIGHTNESS: 80,
        LOOP_VERTICAL_SCALE: 0.5,
        CAMERA_LOOK_BEHIND: 2.5,
        CAMERA_LOOK_AHEAD: 4,
        CAMERA_HEIGHT: 80,
        FOV: 500,
        FOV_MIN: 200,
        FOV_MAX: 1200,
        NEAR_CLIP: 20,
        FAR_CLIP: 3000,
        BASE_FONT_SIZE: 42,
        MIN_FONT_SIZE: 6,
        SCROLL_SPEED: 0.015,
        ROTATION_SPEED: 0.003,
        MOMENTUM_DECAY: 0.95,
        PREFETCH_THRESHOLD: 30,
        BACKWARD_PREFETCH_THRESHOLD: 30,
        SHOW_CONNECTOR: true,
        CONNECTOR_OPACITY: 0.15,
        AUTO_SPEED_MIN: 0.2,
        AUTO_SPEED_MAX: 5.0,
        AUTO_SPEED_DEFAULT: 1.0,
        MAX_PITCH: Math.PI / 3,
        MAX_YAW: Math.PI / 2,
    }
};
function ropePathPosition(t) {
    const cfg = rope3d.config;
    const smoothWave = (theta) => {
        const normalized = (Math.sin(theta) + 1) / 2;
        const smoothed = normalized * normalized * (3 - 2 * normalized);
        return smoothed * 2 - 1;
    };
    const theta1X = (t / cfg.CURVE_PERIOD_X) * Math.PI * 2;
    const theta1Y = (t / cfg.CURVE_PERIOD_Y) * Math.PI * 2;
    const theta2X = (t / cfg.CURVE2_PERIOD_X) * Math.PI * 2;
    const theta2Y = (t / cfg.CURVE2_PERIOD_Y) * Math.PI * 2;
    let x = smoothWave(theta1X) * cfg.CURVE_AMPLITUDE_X +
        Math.sin(theta2X) * cfg.CURVE2_AMPLITUDE_X;
    let y = smoothWave(theta1Y) * cfg.CURVE_AMPLITUDE_Y +
        Math.sin(theta2Y + Math.PI / 4) * cfg.CURVE2_AMPLITUDE_Y;
    if (cfg.LOOP_AMPLITUDE > 0) {
        const loopPhase = (t / cfg.LOOP_PERIOD) * Math.PI * 2;
        const rawActivation = Math.max(0, Math.sin(loopPhase));
        const loopActivation = rawActivation * rawActivation * rawActivation;
        if (loopActivation > 0.001) {
            const loopT = (t / cfg.LOOP_TIGHTNESS) * Math.PI * 2;
            x += Math.sin(loopT) * cfg.LOOP_AMPLITUDE * loopActivation;
            y += (Math.cos(loopT) - 1) * cfg.LOOP_AMPLITUDE * cfg.LOOP_VERTICAL_SCALE * loopActivation;
        }
    }
    return {
        x: x,
        y: y,
        z: t * cfg.WORD_SPACING
    };
}
function computeCameraFrame(wordOffset) {
    const cfg = rope3d.config;
    const camT = wordOffset - cfg.CAMERA_LOOK_BEHIND;
    const camPosOnSpline = ropePathPosition(camT);
    const camPos = {
        x: camPosOnSpline.x,
        y: camPosOnSpline.y + cfg.CAMERA_HEIGHT,
        z: camPosOnSpline.z
    };
    const lookT = camT + cfg.CAMERA_LOOK_AHEAD;
    const lookPos = ropePathPosition(lookT);
    let fx = lookPos.x - camPos.x;
    let fy = lookPos.y - camPos.y;
    let fz = lookPos.z - camPos.z;
    const fLen = Math.sqrt(fx * fx + fy * fy + fz * fz);
    fx /= fLen;
    fy /= fLen;
    fz /= fLen;
    let upX = 0, upY = 1, upZ = 0;
    let rx = fy * upZ - fz * upY;
    let ry = fz * upX - fx * upZ;
    let rz = fx * upY - fy * upX;
    const rLen = Math.sqrt(rx * rx + ry * ry + rz * rz);
    rx /= rLen;
    ry /= rLen;
    rz /= rLen;
    upX = ry * fz - rz * fy;
    upY = rz * fx - rx * fz;
    upZ = rx * fy - ry * fx;
    const yaw = rope3d.cameraYaw;
    const pitch = rope3d.cameraPitch;
    if (Math.abs(yaw) > 0.001 || Math.abs(pitch) > 0.001) {
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        let fx2 = fx * cosY + rx * sinY;
        let fy2 = fy;
        let fz2 = fz * cosY + rz * sinY;
        let rx2 = rx * cosY - fx * sinY;
        let ry2 = ry;
        let rz2 = rz * cosY - fz * sinY;
        const cosP = Math.cos(pitch);
        const sinP = Math.sin(pitch);
        fx = fx2 * cosP - upX * sinP;
        fy = fy2 * cosP - upY * sinP;
        fz = fz2 * cosP - upZ * sinP;
        upX = upX * cosP + fx2 * sinP;
        upY = upY * cosP + fy2 * sinP;
        upZ = upZ * cosP + fz2 * sinP;
        rx = rx2;
        ry = ry2;
        rz = rz2;
    }
    return {
        pos: camPos,
        forward: { x: fx, y: fy, z: fz },
        right: { x: rx, y: ry, z: rz },
        up: { x: upX, y: upY, z: upZ }
    };
}
function projectToCameraSpace(worldPos, camFrame, W, H) {
    const cfg = rope3d.config;
    const dx = worldPos.x - camFrame.pos.x;
    const dy = worldPos.y - camFrame.pos.y;
    const dz = worldPos.z - camFrame.pos.z;
    const camX = dx * camFrame.right.x + dy * camFrame.right.y + dz * camFrame.right.z;
    const camY = dx * camFrame.up.x + dy * camFrame.up.y + dz * camFrame.up.z;
    const camZ = dx * camFrame.forward.x + dy * camFrame.forward.y + dz * camFrame.forward.z;
    if (camZ <= 0)
        return null;
    const scale = cfg.FOV / camZ;
    return {
        screenX: camX * scale + W / 2,
        screenY: -camY * scale + H / 2,
        scale,
        depth: camZ
    };
}
function ropeOpacity(depth) {
    const cfg = rope3d.config;
    if (depth < cfg.NEAR_CLIP || depth > cfg.FAR_CLIP)
        return 0;
    const range = cfg.FAR_CLIP - cfg.NEAR_CLIP;
    const t = (depth - cfg.NEAR_CLIP) / range;
    const fadeIn = Math.min(1, (depth - cfg.NEAR_CLIP) / 100);
    const fadeOut = Math.pow(1 - t, 0.5);
    return Math.max(0, Math.min(1, fadeIn * fadeOut));
}
function initRope3D() {
    rope3d.canvas = $('canvas3d');
    rope3d.ctx = rope3d.canvas.getContext('2d');
    resizeRopeCanvas();
    window.addEventListener('resize', resizeRopeCanvas);
    rope3d.canvas.addEventListener('wheel', handleRopeWheel, { passive: false });
    rope3d.canvas.addEventListener('pointerdown', handleRopePointerDown);
    rope3d.canvas.addEventListener('pointermove', handleRopePointerMove);
    rope3d.canvas.addEventListener('pointerup', handleRopePointerUp);
    rope3d.canvas.addEventListener('pointercancel', handleRopePointerUp);
}
function resizeRopeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    rope3d.canvas.width = window.innerWidth * dpr;
    rope3d.canvas.height = window.innerHeight * dpr;
    rope3d.canvas.style.width = window.innerWidth + 'px';
    rope3d.canvas.style.height = window.innerHeight + 'px';
}
function toggleRopeMode() {
    rope3d.active = !rope3d.active;
    if (jumpAround.active) {
        stopJumpAround();
    }
    if (rope3d.active) {
        if (autoRead.active && autoRead.intervalId) {
            clearInterval(autoRead.intervalId);
            autoRead.intervalId = null;
        }
        document.body.classList.add('mode-3d');
        rope3d.canvas.classList.add('visible');
        $('modeToggle').textContent = '';
        $('autoChunkSize').disabled = true;
        $('autoInterval').disabled = true;
        rope3d.cameraPitch = 0;
        rope3d.cameraYaw = 0;
        rope3d.justToggledFrames = 30;
        const content = getContentText();
        const words = tokenizeForRope(content);
        setRopeWords(words);
        rope3d.wordOffset = 0;
        rope3d.lastWordOffset = 0;
        rope3d.momentum = 0;
        rope3d.firstByteStart = state.byteStart || 0;
        rope3d.lastByteEnd = state.byteEnd || 0;
        rope3d.viewBytePosition = state.byteStart || 0;
        rope3d.backwardHistory = [...navHistoryStack];
        if (rope3d.allWords.length > 0 && state.byteEnd > state.byteStart) {
            rope3d.bytesPerWord = (state.byteEnd - state.byteStart) / rope3d.allWords.length;
        }
        startRopeAnimation();
    }
    else {
        document.body.classList.remove('mode-3d');
        rope3d.canvas.classList.remove('visible');
        $('modeToggle').textContent = '';
        $('autoChunkSize').disabled = false;
        $('autoInterval').disabled = !autoRead.active;
        updateRopeToState();
        stopRopeAnimation();
        if (autoRead.active) {
            const interval = parseInt($('autoInterval').value, 10) * 1000;
            const direction = $('autoDirection').value;
            autoRead.intervalId = setInterval(() => {
                const currentPercent = parseFloat($('percent').textContent) || 0;
                const atEnd = direction === 'forward' && (state.nextByteStart == null || currentPercent >= 99.5);
                const atStart = direction === 'backward' && navHistoryStack.length === 0 && currentPercent <= 0.5;
                if (atEnd || atStart) {
                    fadeAndExecute(() => teleportToRandomLocation());
                    return;
                }
                navigate(direction);
            }, interval);
        }
    }
}
function updateRopeToState() {
    if (!rope3d.active || rope3d.allWords.length === 0)
        return;
    state.byteStart = Math.max(0, Math.floor(rope3d.viewBytePosition));
}
async function reloadRopeWithChunkSize(newChunkSize) {
    if (!rope3d.active || state.loading)
        return;
    state.loading = true;
    try {
        const currentByte = Math.floor(rope3d.viewBytePosition);
        const data = await fetchChunk(state.bookId, currentByte, newChunkSize);
        state.byteStart = data.byteStart;
        state.byteEnd = data.byteEnd;
        state.nextByteStart = data.nextByteStart;
        state.chunkSize = newChunkSize;
        const newText = data.formattedText || data.words.join(' ');
        const words = tokenizeForRope(newText);
        setRopeWords(words);
        rope3d.wordOffset = 0;
        rope3d.firstByteStart = data.byteStart;
        rope3d.lastByteEnd = data.byteEnd;
        rope3d.viewBytePosition = data.byteStart;
        rope3d.backwardHistory = [...navHistoryStack];
        if (rope3d.allWords.length > 0) {
            rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
        }
        showHint(`Loaded ${rope3d.allWords.length} words`);
    }
    catch (err) {
        console.error('Failed to reload rope:', err);
    }
    finally {
        state.loading = false;
    }
}
async function teleportToRandomLocation() {
    if (state.loading)
        return;
    state.loading = true;
    updateButtonStates();
    const modal = $('teleportModal');
    const MAX_RETRIES = 15;
    let attempts = 0;
    const lang = $('searchLanguage').value;
    while (attempts < MAX_RETRIES) {
        attempts++;
        try {
            const randomRes = await fetch('/api/random?lang=' + encodeURIComponent(lang));
            if (!randomRes.ok) {
                throw new Error('Failed to get random book');
            }
            const book = await randomRes.json();
            if (book.error)
                throw new Error(book.error);
            const randomBookId = parseInt(book.id, 10);
            showBookChangeModal(book.title, book.author, false);
            const initRes = await fetch(`/api/book/${randomBookId}/init?chunkSize=${state.chunkSize}`);
            if (!initRes.ok) {
                modal.classList.remove('visible');
                console.log(`Book ${randomBookId} failed to init, trying another... (attempt ${attempts})`);
                continue;
            }
            const initData = await initRes.json();
            if (initData.error) {
                modal.classList.remove('visible');
                console.log(`Book ${randomBookId} error: ${initData.error}, trying another... (attempt ${attempts})`);
                continue;
            }
            const randomPercent = Math.floor(Math.random() * 90) + 5;
            const totalCleanBytes = initData.docEnd - initData.docStart;
            const randomByteOffset = Math.floor(totalCleanBytes * (randomPercent / 100));
            const randomByteStart = initData.docStart + randomByteOffset;
            const data = await fetchChunk(randomBookId, randomByteStart, state.chunkSize);
            state.bookId = randomBookId;
            state.byteStart = data.byteStart;
            state.byteEnd = data.byteEnd;
            state.nextByteStart = data.nextByteStart ?? null;
            state.docStart = initData.docStart;
            state.docEnd = initData.docEnd;
            state.bookTitle = book.title || '';
            state.bookAuthor = book.author || '';
            navHistoryStack.length = 0;
            $('titleBarTitle').textContent = state.bookTitle || `Book ${randomBookId}`;
            $('titleBarAuthor').textContent = state.bookAuthor || '';
            if (rope3d.active) {
                fadeCanvas(0.3, 100, () => {
                    const newText = data.formattedText || data.words.join(' ');
                    const words = tokenizeForRope(newText);
                    setRopeWords(words);
                    rope3d.wordOffset = 0;
                    if (!autoRead.active) {
                        rope3d.momentum = 0;
                    }
                    rope3d.firstByteStart = data.byteStart;
                    rope3d.lastByteEnd = data.byteEnd;
                    rope3d.viewBytePosition = data.byteStart;
                    rope3d.backwardHistory = [];
                    rope3d.justToggledFrames = 60;
                    if (rope3d.allWords.length > 0) {
                        rope3d.bytesPerWord = (data.byteEnd - data.byteStart) / rope3d.allWords.length;
                    }
                    fadeCanvas(1, 100);
                });
            }
            else {
                updateUI(data);
            }
            updateHash(true);
            recordNavigation();
            setTimeout(() => {
                modal.classList.remove('visible');
                state.loading = false;
                updateButtonStates();
            }, 500);
            return;
        }
        catch (err) {
            console.error(`Teleport attempt ${attempts} failed:`, err);
            modal.classList.remove('visible');
            if (err.message && err.message.includes('No plain text')) {
                console.log(`Book has no plain text, trying another...`);
                continue;
            }
            continue;
        }
    }
    modal.classList.remove('visible');
    showHint('Could not find a readable book. Please try again.');
    state.loading = false;
    updateButtonStates();
}
function getAutoScrollSpeed() {
    const cfg = rope3d.config;
    const sliderVal = parseInt($('speedSlider').value, 10) / 100;
    return cfg.AUTO_SPEED_MIN + sliderVal * (cfg.AUTO_SPEED_MAX - cfg.AUTO_SPEED_MIN);
}
function getManualMomentum() {
    const speed = getAutoScrollSpeed();
    return speed * 0.015;
}
function getScrollSensitivity() {
    const speed = getAutoScrollSpeed();
    return speed * 0.003;
}
function resetCameraView() {
    rope3d.cameraPitch = 0;
    rope3d.cameraYaw = 0;
    showHint('View reset');
}
function updateSpeedDisplay() {
    const speed = getAutoScrollSpeed();
    $('speedValue').textContent = speed.toFixed(1) + ' w/s';
}
function startRopeAnimation() {
    if (rope3d.animationId)
        return;
    rope3d.lastFrameTime = performance.now();
    let frameCount = 0;
    function animate(time) {
        if (!rope3d.active)
            return;
        frameCount++;
        if (frameCount >= 60) {
            frameCount = 0;
            syncAutoReadUI();
        }
        const dt = Math.min(100, time - rope3d.lastFrameTime) / 1000;
        rope3d.lastFrameTime = time;
        if (state.loading && !jumpAround.active && !autoRead.active) {
            renderRopeFrame(time);
            rope3d.animationId = requestAnimationFrame(animate);
            return;
        }
        if (rope3d.justToggledFrames > 0) {
            rope3d.justToggledFrames--;
        }
        const wordOffsetBefore = rope3d.wordOffset;
        if (autoRead.active && !rope3d.isDragging) {
            const speed = getAutoScrollSpeed();
            const direction = $('autoDirection').value === 'forward' ? 1 : -1;
            rope3d.wordOffset += speed * direction * dt;
        }
        if (!rope3d.isDragging && !autoRead.active && Math.abs(rope3d.momentum) > 0.005) {
            rope3d.wordOffset += rope3d.momentum;
            rope3d.momentum *= rope3d.config.MOMENTUM_DECAY;
        }
        const wordOffsetDelta = rope3d.wordOffset - wordOffsetBefore;
        rope3d.viewBytePosition += wordOffsetDelta * rope3d.bytesPerWord;
        rope3d.viewBytePosition = Math.max(state.docStart || 0, Math.min(rope3d.viewBytePosition, state.docEnd || rope3d.viewBytePosition));
        const isMovingForward = autoRead.active
            ? $('autoDirection').value === 'forward'
            : (wordOffsetDelta > 0.001 || rope3d.momentum > 0.01);
        const docEnd = state.docEnd || 0;
        const docStart = state.docStart || 0;
        const totalBytes = docEnd - docStart;
        const bytesFromStart = rope3d.viewBytePosition - docStart;
        const noMoreContent = state.nextByteStart === null;
        const nearEndByBytes = totalBytes > 0 && bytesFromStart >= totalBytes - 100;
        const atDocEndByPosition = totalBytes > 0 && rope3d.viewBytePosition >= docEnd - 50;
        const nearEndOfWords = rope3d.allWords.length > 0 &&
            rope3d.wordOffset >= rope3d.allWords.length - 10;
        const atForwardBoundary = ((noMoreContent && nearEndByBytes) ||
            (atDocEndByPosition && nearEndOfWords)) &&
            isMovingForward &&
            rope3d.justToggledFrames === 0;
        const isMovingBackward = autoRead.active
            ? $('autoDirection').value === 'backward'
            : (wordOffsetDelta < -0.001 || rope3d.momentum < -0.01);
        const currentPercent = totalBytes > 0 ? ((rope3d.viewBytePosition - docStart) / totalBytes * 100) : 0;
        const atDocStart = rope3d.firstByteStart <= docStart + 100;
        const atWordStart = rope3d.wordOffset <= 1;
        const atBackwardBoundary = atWordStart &&
            (atDocStart || currentPercent <= 0.5) &&
            isMovingBackward &&
            rope3d.justToggledFrames === 0;
        if (atForwardBoundary || atBackwardBoundary) {
            if (jumpAround.active) {
                if (jumpAround.timeoutId) {
                    clearTimeout(jumpAround.timeoutId);
                    jumpAround.timeoutId = null;
                }
                if (jumpAround.sameBook) {
                    goToRandomLocationInSameBook();
                }
                else {
                    goToRandomLocation();
                }
                scheduleNextJump();
            }
            else {
                teleportToRandomLocation();
            }
            rope3d.animationId = requestAnimationFrame(animate);
            return;
        }
        const maxWord = Math.max(0, rope3d.allWords.length - 1);
        const minWord = rope3d.firstByteStart > (state.docStart || 0) ? -5 : 0;
        rope3d.wordOffset = Math.max(minWord, Math.min(rope3d.wordOffset, maxWord));
        checkRopePrefetch();
        renderRopeFrame(time);
        rope3d.animationId = requestAnimationFrame(animate);
    }
    rope3d.animationId = requestAnimationFrame(animate);
}
function stopRopeAnimation() {
    if (rope3d.animationId) {
        cancelAnimationFrame(rope3d.animationId);
        rope3d.animationId = null;
    }
}
function renderRopeFrame(time) {
    const ctx = rope3d.ctx;
    const dpr = window.devicePixelRatio || 1;
    const W = window.innerWidth;
    const H = window.innerHeight;
    const cfg = rope3d.config;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    const style = getComputedStyle(document.documentElement);
    const bgColor = style.getPropertyValue('--canvas-bg').trim() || '#ffffff';
    const textColor = style.getPropertyValue('--rope-text').trim() || '#000000';
    const fontFamily = style.getPropertyValue('--font-body').trim() || 'Georgia, serif';
    const textRgb = parseColorToRgb(textColor);
    const bgRgb = parseColorToRgb(bgColor);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, W, H);
    if (rope3d.allWords.length === 0) {
        ctx.fillStyle = style.getPropertyValue('--text-muted').trim() || 'rgba(0,0,0,0.5)';
        ctx.font = `18px ${fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Loading text...', W / 2, H / 2);
        return;
    }
    const camFrame = computeCameraFrame(rope3d.wordOffset);
    const visibleWords = Math.ceil(cfg.FAR_CLIP / cfg.WORD_SPACING) + 5;
    const startWord = Math.max(0, Math.floor(rope3d.wordOffset) - 3);
    const endWord = Math.min(rope3d.allWords.length - 1, startWord + visibleWords);
    const wordsToRender = [];
    for (let i = startWord; i <= endWord; i++) {
        const word = rope3d.allWords[i];
        if (!word || word.trim() === '')
            continue;
        const worldPos = ropePathPosition(i);
        const proj = projectToCameraSpace(worldPos, camFrame, W, H);
        if (!proj)
            continue;
        if (proj.depth < cfg.NEAR_CLIP || proj.depth > cfg.FAR_CLIP)
            continue;
        if (proj.screenX < -200 || proj.screenX > W + 200)
            continue;
        if (proj.screenY < -200 || proj.screenY > H + 200)
            continue;
        wordsToRender.push({
            word,
            index: i,
            worldPos,
            proj,
            opacity: ropeOpacity(proj.depth)
        });
    }
    wordsToRender.sort((a, b) => b.proj.depth - a.proj.depth);
    if (cfg.SHOW_CONNECTOR && wordsToRender.length > 1) {
        drawWordConnector(ctx, wordsToRender, camFrame, W, H);
    }
    for (const item of wordsToRender) {
        const effectiveOpacity = item.opacity * canvasFadeOpacity;
        if (effectiveOpacity < 0.02)
            continue;
        const fontSize = Math.max(cfg.MIN_FONT_SIZE, cfg.BASE_FONT_SIZE * item.proj.scale);
        if (fontSize < 5)
            continue;
        ctx.save();
        ctx.translate(item.proj.screenX, item.proj.screenY);
        const isItalic = rope3d.wordItalicMap[item.index] || false;
        const fontStyle = isItalic ? 'italic ' : '';
        ctx.font = `${fontStyle}${Math.round(fontSize)}px ${fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const depthFactor = item.proj.depth / cfg.FAR_CLIP;
        const r = Math.round(textRgb.r + (bgRgb.r - textRgb.r) * depthFactor);
        const g = Math.round(textRgb.g + (bgRgb.g - textRgb.g) * depthFactor);
        const b = Math.round(textRgb.b + (bgRgb.b - textRgb.b) * depthFactor);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${effectiveOpacity})`;
        ctx.fillText(item.word, 0, 0);
        ctx.restore();
    }
    const totalBytes = (state.docEnd || 1) - (state.docStart || 0);
    const bytesFromStart = Math.max(0, rope3d.viewBytePosition - (state.docStart || 0));
    const percent = totalBytes > 0 ? Math.min(100, (bytesFromStart / totalBytes) * 100).toFixed(1) : 0;
    $('percent').textContent = `${percent}%`;
    $('progress').style.width = `${percent}%`;
    updateFooterLocation();
}
function drawWordConnector(ctx, wordsToRender, camFrame, W, H) {
    const cfg = rope3d.config;
    const sorted = [...wordsToRender].sort((a, b) => a.index - b.index);
    ctx.beginPath();
    let lastIndex = -999;
    for (const item of sorted) {
        if (item.index - lastIndex === 1) {
            ctx.lineTo(item.proj.screenX, item.proj.screenY);
        }
        else {
            ctx.moveTo(item.proj.screenX, item.proj.screenY);
        }
        lastIndex = item.index;
    }
    ctx.strokeStyle = `rgba(200, 200, 200, ${cfg.CONNECTOR_OPACITY * 3 * canvasFadeOpacity})`;
    ctx.lineWidth = 1;
    ctx.stroke();
}
async function checkRopePrefetch() {
    if (state.loading)
        return;
    const cfg = rope3d.config;
    const wordsRemaining = rope3d.allWords.length - Math.floor(rope3d.wordOffset);
    const wordsFromStart = Math.floor(rope3d.wordOffset);
    if (wordsRemaining < cfg.PREFETCH_THRESHOLD && state.nextByteStart !== null) {
        await loadMoreRopeContent('forward');
    }
    if (wordsFromStart < cfg.BACKWARD_PREFETCH_THRESHOLD && rope3d.firstByteStart > (state.docStart || 0)) {
        await loadMoreRopeContent('backward');
    }
    const atDocStart = rope3d.firstByteStart <= (state.docStart || 0) + 100;
    const isMovingBackward = autoRead.active
        ? $('autoDirection').value === 'backward'
        : rope3d.momentum < -0.001;
    if (atDocStart && wordsFromStart < cfg.BACKWARD_PREFETCH_THRESHOLD && isMovingBackward) {
        rope3d.wordOffset = 0;
        rope3d.viewBytePosition = state.docStart || 0;
    }
    const atDocEnd = state.nextByteStart === null;
    const isMovingForward = autoRead.active
        ? $('autoDirection').value === 'forward'
        : rope3d.momentum > 0.001;
    if (atDocEnd && wordsRemaining < cfg.PREFETCH_THRESHOLD && isMovingForward) {
        rope3d.viewBytePosition = state.docEnd || rope3d.viewBytePosition;
    }
    updateRopeToState();
}
async function loadMoreRopeContent(direction = 'forward') {
    if (state.loading)
        return;
    if (direction === 'forward') {
        if (state.nextByteStart == null)
            return;
        state.loading = true;
        try {
            navHistoryStack.push(state.byteStart);
            const data = await fetchChunk(state.bookId, state.nextByteStart, state.chunkSize);
            if (data.actualCount === 0 || (data.words && data.words.length === 0)) {
                navHistoryStack.pop();
                state.nextByteStart = null;
                state.loading = false;
                return;
            }
            state.byteStart = data.byteStart;
            state.byteEnd = data.byteEnd;
            state.nextByteStart = data.nextByteStart ?? null;
            const newText = data.formattedText || data.words.join(' ');
            const newWords = tokenizeForRope(newText);
            appendRopeWords(newWords);
            rope3d.lastByteEnd = data.byteEnd;
            if (rope3d.allWords.length > 0) {
                rope3d.bytesPerWord = (rope3d.lastByteEnd - rope3d.firstByteStart) / rope3d.allWords.length;
            }
        }
        catch (err) {
            console.error('Rope prefetch forward failed:', err);
            navHistoryStack.pop();
        }
        finally {
            state.loading = false;
        }
    }
    else {
        if (rope3d.firstByteStart <= (state.docStart || 0)) {
            rope3d.wordOffset = 0;
            rope3d.viewBytePosition = state.docStart || 0;
            return;
        }
        state.loading = true;
        try {
            const bytesToGoBack = Math.floor(state.chunkSize * rope3d.bytesPerWord);
            const prevByteStart = Math.max(state.docStart || 0, rope3d.firstByteStart - bytesToGoBack);
            if (prevByteStart >= rope3d.firstByteStart) {
                rope3d.firstByteStart = state.docStart || 0;
                rope3d.wordOffset = 0;
                rope3d.viewBytePosition = state.docStart || 0;
                state.loading = false;
                return;
            }
            const data = await fetchChunk(state.bookId, prevByteStart, state.chunkSize);
            if (data.actualCount === 0 || (data.words && data.words.length === 0)) {
                rope3d.firstByteStart = state.docStart || 0;
                rope3d.wordOffset = 0;
                rope3d.viewBytePosition = state.docStart || 0;
                state.loading = false;
                return;
            }
            const minExpectedProgress = Math.max(1, Math.floor(bytesToGoBack * 0.5));
            if (data.byteStart >= rope3d.firstByteStart - minExpectedProgress) {
                rope3d.firstByteStart = state.docStart || 0;
                rope3d.wordOffset = 0;
                rope3d.viewBytePosition = state.docStart || 0;
                state.loading = false;
                return;
            }
            const newText = data.formattedText || data.words.join(' ');
            const newWords = tokenizeForRope(newText);
            const wordCountBefore = rope3d.allWords.length;
            prependRopeWords(newWords);
            const addedWords = rope3d.allWords.length - wordCountBefore;
            rope3d.wordOffset += addedWords;
            rope3d.firstByteStart = data.byteStart;
            if (rope3d.allWords.length > 0) {
                rope3d.bytesPerWord = (rope3d.lastByteEnd - rope3d.firstByteStart) / rope3d.allWords.length;
            }
        }
        catch (err) {
            console.error('Rope prefetch backward failed:', err);
        }
        finally {
            state.loading = false;
        }
    }
}
function handleRopeWheel(e) {
    if (!rope3d.active)
        return;
    e.preventDefault();
    rope3d.momentum += (e.deltaY > 0 ? 1 : -1) * getScrollSensitivity();
}
function handleRopePointerDown(e) {
    if (!rope3d.active)
        return;
    rope3d.isRotating = true;
    rope3d.lastX = e.clientX;
    rope3d.lastY = e.clientY;
    rope3d.lastTime = Date.now();
    rope3d.canvas.setPointerCapture(e.pointerId);
}
function handleRopePointerMove(e) {
    if (!rope3d.active || !rope3d.isRotating)
        return;
    const cfg = rope3d.config;
    const deltaX = e.clientX - rope3d.lastX;
    const deltaY = e.clientY - rope3d.lastY;
    rope3d.cameraYaw += deltaX * cfg.ROTATION_SPEED;
    rope3d.cameraPitch += deltaY * cfg.ROTATION_SPEED;
    rope3d.cameraYaw = Math.max(-cfg.MAX_YAW, Math.min(cfg.MAX_YAW, rope3d.cameraYaw));
    rope3d.cameraPitch = Math.max(-cfg.MAX_PITCH, Math.min(cfg.MAX_PITCH, rope3d.cameraPitch));
    rope3d.lastX = e.clientX;
    rope3d.lastY = e.clientY;
}
function handleRopePointerUp(e) {
    if (!rope3d.active)
        return;
    rope3d.isRotating = false;
    rope3d.canvas.releasePointerCapture(e.pointerId);
}
function syncRopeWords() {
    if (!rope3d.active)
        return;
    const content = getContentText();
    const newWords = tokenizeForRope(content);
    if (newWords.length > 0) {
        const currentWords = rope3d.allWords.join(' ');
        const newWordsStr = newWords.join(' ');
        if (currentWords !== newWordsStr) {
            setRopeWords(newWords);
            rope3d.wordOffset = 0;
            rope3d.firstByteStart = state.byteStart || 0;
            rope3d.lastByteEnd = state.byteEnd || 0;
            rope3d.viewBytePosition = state.byteStart || 0;
            if (rope3d.allWords.length > 0 && state.byteEnd > state.byteStart) {
                rope3d.bytesPerWord = (state.byteEnd - state.byteStart) / rope3d.allWords.length;
            }
        }
    }
    else if (rope3d.allWords.length === 0) {
        setRopeWords(newWords);
        rope3d.wordOffset = 0;
    }
}
function syncRopeFromContent() {
    if (!rope3d.active)
        return;
    const content = getContentText();
    const words = tokenizeForRope(content);
    setRopeWords(words);
    rope3d.wordOffset = 0;
    rope3d.momentum = 0;
    rope3d.firstByteStart = state.byteStart || 0;
    rope3d.lastByteEnd = state.byteEnd || 0;
    rope3d.viewBytePosition = state.byteStart || 0;
    rope3d.backwardHistory = [...navHistoryStack];
    if (rope3d.allWords.length > 0 && state.byteEnd > state.byteStart) {
        rope3d.bytesPerWord = (state.byteEnd - state.byteStart) / rope3d.allWords.length;
    }
}
initRope3D();
$('modeToggle').addEventListener('click', (e) => {
    e.target.blur();
    toggleRopeMode();
    refocusAfterButton();
});
$('speedSlider').addEventListener('input', updateSpeedDisplay);
$('speedSlider').addEventListener('change', () => {
    $('speedSlider').blur();
    if (rope3d.active)
        rope3d.canvas.focus();
});
updateSpeedDisplay();
const savedThroughLine = localStorage.getItem('gutex-through-line');
const showLine = savedThroughLine === 'true';
$('showThroughLine').checked = showLine;
rope3d.config.SHOW_CONNECTOR = showLine;
$('showThroughLine').addEventListener('change', (e) => {
    rope3d.config.SHOW_CONNECTOR = e.target.checked;
    localStorage.setItem('gutex-through-line', e.target.checked);
    $('floatingThroughLine').checked = e.target.checked;
});

$('floatingSpeedSlider').addEventListener('input', (e) => {
    $('speedSlider').value = e.target.value;
    updateSpeedDisplay();
});
$('floatingSpeedSlider').addEventListener('change', () => {
    if (rope3d.active)
        rope3d.canvas.focus();
});
$('floatingThroughLine').addEventListener('change', (e) => {
    $('showThroughLine').checked = e.target.checked;
    rope3d.config.SHOW_CONNECTOR = e.target.checked;
    localStorage.setItem('gutex-through-line', e.target.checked);
});
function syncFloatingControls() {
    if (!$('floatingSpeedSlider'))
        return;
    $('floatingSpeedSlider').value = $('speedSlider').value;
    $('floatingSpeedValue').textContent = $('speedValue').textContent;
    $('floatingThroughLine').checked = $('showThroughLine').checked;
    $('floatingPercent').textContent = $('percent').textContent;
    $('floatingProgressFill').style.width = $('progressFill').style.width;
}
const originalUpdateSpeedDisplay = updateSpeedDisplay;
updateSpeedDisplay = function () {
    originalUpdateSpeedDisplay();
    if ($('floatingSpeedValue')) {
        $('floatingSpeedValue').textContent = $('speedValue').textContent;
        $('floatingSpeedSlider').value = $('speedSlider').value;
    }
};
setInterval(() => {
    if (rope3d.active && $('floatingPercent')) {
        $('floatingPercent').textContent = $('percent').textContent;
        $('floatingProgressFill').style.width = $('progressFill').style.width;
    }
}, 500);
syncFloatingControls();
$('controlsToggle').addEventListener('click', () => {
    $('floating3dControls').classList.toggle('expanded');
    localStorage.setItem('gutex-controls-expanded', $('floating3dControls').classList.contains('expanded'));
});
if (localStorage.getItem('gutex-controls-expanded') === 'true') {
    $('floating3dControls').classList.add('expanded');
}

let progressSeekTimeout = null;
const PROGRESS_SEEK_DEBOUNCE = 300;
let activeProgressTrack = null;
function calculateByteFromPercent(percent) {
    const docStart = state.docStart || 0;
    const docEnd = state.docEnd || 0;
    if (docEnd <= docStart)
        return null;
    const targetByte = Math.floor(docStart + (percent / 100) * (docEnd - docStart));
    return Math.max(docStart, Math.min(docEnd, targetByte));
}
function updateProgressDisplay(percent) {
    const clampedPercent = Math.max(0, Math.min(100, percent));
    $('progressFill').style.width = `${clampedPercent}%`;
    $('progress').style.width = `${clampedPercent}%`;
    $('percent').textContent = `${Math.round(clampedPercent)}%`;
    if ($('floatingProgressFill')) {
        $('floatingProgressFill').style.width = `${clampedPercent}%`;
        $('floatingPercent').textContent = `${Math.round(clampedPercent)}%`;
    }
    if ($('floatingPercentCompact')) {
        $('floatingPercentCompact').textContent = `${Math.round(clampedPercent)}%`;
    }
}
function seekToPercent(percent) {
    if (!state.bookId || state.loading)
        return;
    const targetByte = calculateByteFromPercent(percent);
    if (targetByte === null)
        return;
    if (progressSeekTimeout) {
        clearTimeout(progressSeekTimeout);
    }
    updateProgressDisplay(percent);
    progressSeekTimeout = setTimeout(() => {
        initBook(state.bookId, targetByte, state.chunkSize, false, false).catch(err => {
            console.error('Progress seek navigation failed:', err);
        });
    }, PROGRESS_SEEK_DEBOUNCE);
}
function getPercentFromEvent(e, track) {
    const rect = track.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const x = clientX - rect.left;
    return Math.max(0, Math.min(100, (x / rect.width) * 100));
}
document.addEventListener('mousemove', (e) => {
    if (!activeProgressTrack)
        return;
    e.preventDefault();
    const percent = getPercentFromEvent(e, activeProgressTrack);
    seekToPercent(percent);
});
document.addEventListener('mouseup', () => {
    if (activeProgressTrack) {
        activeProgressTrack.classList.remove('dragging');
        activeProgressTrack = null;
    }
});
document.addEventListener('touchmove', (e) => {
    if (!activeProgressTrack)
        return;
    e.preventDefault();
    const percent = getPercentFromEvent(e, activeProgressTrack);
    seekToPercent(percent);
}, { passive: false });
document.addEventListener('touchend', () => {
    if (activeProgressTrack) {
        activeProgressTrack.classList.remove('dragging');
        activeProgressTrack = null;
    }
});
document.addEventListener('touchcancel', () => {
    if (activeProgressTrack) {
        activeProgressTrack.classList.remove('dragging');
        activeProgressTrack = null;
    }
});
function setupProgressTrack(trackElement) {
    if (!trackElement)
        return;
    function handleStart(e) {
        if (!state.bookId || state.loading || !state.docEnd)
            return;
        e.preventDefault();
        e.stopPropagation();
        activeProgressTrack = trackElement;
        trackElement.classList.add('dragging');
        const percent = getPercentFromEvent(e, trackElement);
        seekToPercent(percent);
    }
    trackElement.addEventListener('mousedown', handleStart);
    trackElement.addEventListener('touchstart', handleStart, { passive: false });
}
setupProgressTrack(document.querySelector('.header-track'));
setupProgressTrack(document.querySelector('.floating-3d-controls .progress-track'));

const posButtons = document.querySelectorAll('.floating-3d-controls .pos-btn');
posButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        const pos = btn.dataset.pos;
        const panel = $('floating3dControls');
        panel.classList.remove('pos-top-left', 'pos-top-right', 'pos-bottom-left', 'pos-bottom-right');
        if (pos !== 'bottom-right') {
            panel.classList.add('pos-' + pos);
        }
        posButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        localStorage.setItem('gutex-controls-position', pos);
    });
});
const savedPos = localStorage.getItem('gutex-controls-position');
if (savedPos && savedPos !== 'bottom-right') {
    $('floating3dControls').classList.add('pos-' + savedPos);
    posButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.pos === savedPos);
    });
}
const originalSyncFloating = syncFloatingControls;
syncFloatingControls = function () {
    originalSyncFloating();
    if ($('floatingPercentCompact')) {
        $('floatingPercentCompact').textContent = $('percent').textContent;
    }
};
setInterval(() => {
    if (rope3d.active && $('floatingPercentCompact')) {
        $('floatingPercentCompact').textContent = $('percent').textContent;
    }
}, 500);

function isExcerptMode() {
    return window.location.search.includes('excerpt=1');
}
function openExcerptView() {
    const base = window.location.origin + window.location.pathname;
    const currentTheme = localStorage.getItem('gutex-theme') || 'default';
    const currentByte = rope3d.active ? Math.floor(rope3d.viewBytePosition) : state.byteStart;
    const hash = `#${state.bookId},${currentByte},${state.chunkSize}`;
    window.open(`${base}?excerpt=1&theme=${currentTheme}${hash}`, '_blank');
}
function formatExcerptText(text) {
    let formatted = text.trim().replace(/"/g, "'");
    const startsWithCapital = /^[A-Z]/.test(formatted);
    const endsWithPunctuation = /[.!?;:,'"')\]]$/.test(formatted);
    const leftEllipsis = startsWithCapital ? '' : ' ';
    const rightEllipsis = endsWithPunctuation ? '' : ' ';
    return '"' + leftEllipsis + formatted + rightEllipsis + '"';
}
async function initExcerptMode() {
    document.body.classList.add('excerpt-mode');
    $('content').textContent = 'Loading...';
    const homeLink = document.createElement('a');
    homeLink.href = '/';
    homeLink.className = 'excerpt-home-link';
    homeLink.textContent = 'gutex';
    document.body.appendChild(homeLink);
    const params = parseHash();
    if (!params) {
        $('content').textContent = 'No book specified.';
        return;
    }
    try {
        const exactRes = await fetch(`/api/book/${params.bookId}/chunk?byteStart=${params.byteStart}&chunkSize=${params.chunkSize}&exact=1`);
        const exactData = await exactRes.json();
        if (!exactData || !exactData.text)
            throw new Error('No content returned');
        const text = exactData.text;
        const byteStart = exactData.byteStart;
        const byteEnd = exactData.byteEnd;
        let bookTitle = `Book ${params.bookId}`;
        let bookAuthor = '';
        try {
            const infoRes = await fetch(`/api/bookinfo/${params.bookId}`);
            const info = await infoRes.json();
            if (info.title)
                bookTitle = info.title;
            if (info.author) {
                bookAuthor = info.author
                    .replace(/,\s*\d{4}-\d{4}/g, '')
                    .replace(/,\s*\d{4}-/g, '')
                    .replace(/,\s*-\d{4}/g, '')
                    .replace(/\s*\[.*?\]/g, '')
                    .split('; ')
                    .map(name => name.split(', ').reverse().join(' ').trim())
                    .join(', ');
            }
        }
        catch (e) { }
        const excerptdText = formatExcerptText(text);
        const sourceText = bookAuthor ? `${bookTitle}, ${bookAuthor}` : bookTitle;
        const gutenbergUrl = `https://www.gutenberg.org/cache/epub/${params.bookId}/pg${params.bookId}.txt`;
        const curlCmd = `curl -s -r ${byteStart}-${byteEnd} "${gutenbergUrl}"`;
        $('content').innerHTML = `
      <div class="excerpt-excerpt">${processItalics(excerptdText)}</div>
      <div class="excerpt-source">${escapeHtml(sourceText)}</div>
      <div class="excerpt-cmd" data-cmd="${escapeHtml(curlCmd)}">
        <span class="cmd-text">${escapeHtml(curlCmd)}</span>
        <button class="copy-btn">Copy?</button>
      </div>
    `;
        $('content').querySelectorAll('.excerpt-cmd .copy-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const cmd = btn.parentElement.dataset.cmd;
                try {
                    await navigator.clipboard.writeText(cmd);
                    btn.textContent = 'Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = 'Copy?';
                        btn.classList.remove('copied');
                    }, 2000);
                }
                catch (e) {
                    btn.textContent = 'Failed';
                    setTimeout(() => { btn.textContent = 'Copy?'; }, 2000);
                }
            });
        });
        document.title = `${bookTitle}  Gutex`;
    }
    catch (err) {
        $('content').textContent = `Error loading text: ${err.message}`;
    }
}
$('excerptBtn').addEventListener('click', (e) => {
    e.target.blur();
    openExcerptView();
});

const P2P_ROOM_KEY = 'gutex_p2p_room';
const p2p = {
    ws: null,
    peerId: null,
    roomId: null,
    roomName: null,
    peers: new Map(),
    streams: new Map(),
    hiddenPeers: new Set(),
    expandedPips: [],
    broadcastInterval: null,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    reconnectTimeout: null,
    isLeaving: false,
    joiningRoom: false
};
function saveP2PRoom(roomId, displayName) {
    try {
        localStorage.setItem(P2P_ROOM_KEY, JSON.stringify({
            roomId: roomId,
            displayName: displayName,
            timestamp: Date.now()
        }));
    }
    catch (e) { }
}
function loadSavedP2PRoom() {
    try {
        const saved = localStorage.getItem(P2P_ROOM_KEY);
        if (!saved)
            return null;
        return JSON.parse(saved);
    }
    catch (e) {
        return null;
    }
}
function clearSavedP2PRoom() {
    try {
        localStorage.removeItem(P2P_ROOM_KEY);
    }
    catch (e) { }
}
const p2pUI = {
    toggle: () => $('p2pToggle'),
    panel: () => $('p2pPanel'),
    status: () => $('p2pStatus'),
    statusDot: () => $('p2pStatusDot'),
    statusText: () => $('p2pStatusText'),
    joinSection: () => $('p2pJoinSection'),
    createSection: () => $('p2pCreateSection'),
    roomSection: () => $('p2pRoomSection'),
    peersSection: () => $('p2pPeersSection'),
    roomCodeDisplay: () => $('p2pRoomCodeDisplay'),
    roomCodeInput: () => $('p2pRoomCodeInput'),
    displayName: () => $('p2pDisplayName'),
    peerList: () => $('p2pPeerList'),
    peerCount: () => $('p2pPeerCount'),
    streamsContainer: () => $('p2pStreamsContainer')
};
function initP2PSignaling() {
    if (p2p.ws && p2p.ws.readyState === WebSocket.CONNECTING) {
        return;
    }
    if (p2p.ws && p2p.ws.readyState === WebSocket.OPEN) {
        return;
    }
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/signaling`;
    try {
        p2p.ws = new WebSocket(wsUrl);
        p2p.ws.onopen = () => {
            p2pLog('p2p_connect', 'Connected to signaling server');
            updateP2PStatus('connected', 'Connected');
            p2p.reconnectAttempts = 0;
            if (!p2p.roomId) {
                const saved = loadSavedP2PRoom();
                if (saved && saved.roomId) {
                    p2pUI.displayName().value = saved.displayName || '';
                    joinP2PRoom(saved.roomId, saved.displayName);
                }
            }
        };
        p2p.ws.onclose = () => {
            p2pLog('p2p_disconnect', 'Disconnected from signaling server');
            updateP2PStatus('disconnected', 'Disconnected');
            p2p.roomId = null;
            p2p.peers.clear();
            updateP2PUI();
            if (p2p.reconnectAttempts < p2p.maxReconnectAttempts) {
                const delay = 3000 * Math.pow(2, p2p.reconnectAttempts);
                p2p.reconnectAttempts++;
                p2pLog('p2p', `Reconnecting in ${delay / 1000}s (attempt ${p2p.reconnectAttempts})`);
                p2p.reconnectTimeout = setTimeout(initP2PSignaling, delay);
            }
            else {
                p2pLog('p2p_error', 'Max reconnect attempts reached, giving up');
            }
        };
        p2p.ws.onerror = (err) => {
            p2pLog('p2p_error', 'WebSocket error');
        };
        p2p.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                handleP2PMessage(message);
            }
            catch (err) {
                p2pLog('p2p_error', `Message handling error: ${err.message || 'Unknown'}`);
            }
        };
    }
    catch (err) {
        p2pLog('p2p_error', 'Failed to create WebSocket connection');
    }
}
function sendP2PMessage(message) {
    if (p2p.ws && p2p.ws.readyState === WebSocket.OPEN) {
        p2p.ws.send(JSON.stringify(message));
    }
}
function handleP2PMessage(message) {
    if (p2p.isLeaving) {
        return;
    }
    switch (message.type) {
        case 'peer-list':
            if (!p2p.roomId)
                return;
            if (message.payload?.yourId) {
                p2p.peerId = message.payload.yourId;
            }
            if (message.payload?.peers) {
                updatePeerList(message.payload.peers);
            }
            if (message.payload?.action === 'joined') {
                p2pLog('p2p_peer', `Peer joined: ${message.payload.peer?.displayName || 'unknown'}`);
            }
            if (message.payload?.action === 'left') {
                p2pLog('p2p_peer', `Peer left: ${message.payload.peerId}`);
                removeStreamPIP(message.payload.peerId);
            }
            break;
        case 'room-info':
            if (!p2p.joiningRoom) {
                p2pLog('p2p', 'Ignoring room-info - not actively joining');
                break;
            }
            p2p.joiningRoom = false;
            p2p.roomId = message.roomId;
            p2p.peerId = message.peerId;
            saveP2PRoom(p2p.roomId, p2pUI.displayName()?.value || '');
            if (message.payload?.room) {
                p2p.roomName = message.payload.room.name;
                if (message.payload.room.peers) {
                    updatePeerList(message.payload.room.peers);
                    message.payload.room.peers.forEach(peer => {
                        if (peer.id !== p2p.peerId && !p2p.streams.has(peer.id)) {
                            createStreamPIP(peer.id);
                        }
                    });
                }
            }
            startSharing();
            updateP2PUI();
            break;
        case 'stream-state':
            handleP2PStreamState(message);
            break;
        case 'error':
            p2p.joiningRoom = false;
            p2pLog('p2p_error', message.payload?.message || 'Unknown error');
            if (message.payload?.message?.includes('not found')) {
                const saved = loadSavedP2PRoom();
                if (saved && saved.roomId) {
                    p2pLog('p2p', `Room ${saved.roomId} expired, recreating...`);
                    createP2PRoomWithId(saved.roomId, saved.displayName);
                }
            }
            else {
                showHint(message.payload?.message || 'P2P Error');
            }
            break;
    }
}
function updateP2PStatus(status, text) {
    p2pUI.statusDot().classList.remove('connected', 'broadcasting');
    p2pUI.toggle().classList.remove('connected', 'broadcasting');
    if (status === 'connected' || status === 'broadcasting') {
        p2pUI.statusDot().classList.add(status);
        p2pUI.toggle().classList.add(status);
    }
    p2pUI.statusText().textContent = text;
}
function updateP2PUI() {
    const inRoom = !!p2p.roomId;
    const nameSection = $('p2pNameSection');
    if (nameSection)
        nameSection.style.display = inRoom ? 'none' : 'block';
    p2pUI.joinSection().style.display = inRoom ? 'none' : 'block';
    p2pUI.createSection().style.display = inRoom ? 'none' : 'block';
    p2pUI.roomSection().style.display = inRoom ? 'block' : 'none';
    p2pUI.peersSection().style.display = inRoom ? 'block' : 'none';
    if (inRoom) {
        p2pUI.roomCodeDisplay().textContent = p2p.roomId;
        updateP2PStatus('connected', `In room ${p2p.roomId}`);
    }
    else {
        updateP2PStatus('connected', 'Not in a room');
    }
}
function updatePeerList(peers) {
    p2p.peers.clear();
    peers.forEach(peer => {
        p2p.peers.set(peer.id, peer);
    });
    p2pUI.peerCount().textContent = p2p.peers.size;
    const listEl = p2pUI.peerList();
    listEl.innerHTML = '';
    p2p.peers.forEach((peer, peerId) => {
        const item = document.createElement('li');
        item.className = 'p2p-peer-item';
        const isYou = peerId === p2p.peerId;
        const isHidden = p2p.hiddenPeers.has(peerId);
        let badges = '';
        if (isYou)
            badges += '<span class="peer-badge you">You</span>';
        let actionBtn = '';
        if (!isYou) {
            if (isHidden) {
                actionBtn = `<button class="show-btn" data-peer-id="${peerId}" style="padding:2px 8px;font-size:10px;background:#e8f5e9;border:1px solid #4caf50;border-radius:3px;cursor:pointer;color:#2e7d32;">Show</button>`;
            }
            else if (p2p.streams.has(peerId)) {
                actionBtn = `<button class="hide-btn" data-peer-id="${peerId}" style="padding:2px 8px;font-size:10px;background:#f0f0f0;border:1px solid #ccc;border-radius:3px;cursor:pointer;">Hide</button>`;
            }
        }
        item.innerHTML = `
      <div class="peer-info">
        <span>${escapeHtml(peer.displayName)}${isHidden ? ' <span style="color:#888;font-size:10px;">(hidden)</span>' : ''}</span>
        ${badges}
      </div>
      ${actionBtn}
    `;
        listEl.appendChild(item);
    });
    listEl.querySelectorAll('.hide-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const peerId = btn.dataset.peerId;
            p2p.hiddenPeers.add(peerId);
            removeStreamPIP(peerId);
            updatePeerList(Array.from(p2p.peers.values()));
        });
    });
    listEl.querySelectorAll('.show-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const peerId = btn.dataset.peerId;
            p2p.hiddenPeers.delete(peerId);
            createStreamPIP(peerId);
            updatePeerList(Array.from(p2p.peers.values()));
        });
    });
}
function startSharing() {
    if (p2p.broadcastInterval)
        return;
    shareState();
    p2p.broadcastInterval = setInterval(shareState, 250);
    p2pLog('p2p', 'Started sharing');
}
function stopSharing() {
    if (p2p.broadcastInterval) {
        clearInterval(p2p.broadcastInterval);
        p2p.broadcastInterval = null;
    }
    p2pLog('p2p', 'Stopped sharing');
}
function shareState() {
    if (!p2p.roomId)
        return;
    const streamState = {
        type: 'reading',
        bookId: state.bookId,
        bookTitle: state.bookTitle,
        bookAuthor: state.bookAuthor,
        byteStart: state.byteStart,
        byteEnd: state.byteEnd,
        chunkSize: state.chunkSize,
        percent: $('percent')?.textContent || '0%',
        mode: rope3d.active ? '3d' : '2d',
        timestamp: Date.now()
    };
    if (rope3d.active && rope3d.allWords.length > 0) {
        const cfg = rope3d.config;
        const W = window.innerWidth;
        const H = window.innerHeight;
        const camFrame = computeCameraFrame(rope3d.wordOffset);
        const visibleWordCount = Math.ceil(cfg.FAR_CLIP / cfg.WORD_SPACING) + 5;
        const startWord = Math.max(0, Math.floor(rope3d.wordOffset) - 3);
        const endWord = Math.min(rope3d.allWords.length - 1, startWord + visibleWordCount);
        const projectedWords = [];
        for (let i = startWord; i <= endWord && projectedWords.length < 60; i++) {
            const word = rope3d.allWords[i];
            if (!word || word.trim() === '')
                continue;
            const worldPos = ropePathPosition(i);
            const proj = projectToCameraSpace(worldPos, camFrame, W, H);
            if (!proj)
                continue;
            if (proj.depth < cfg.NEAR_CLIP || proj.depth > cfg.FAR_CLIP)
                continue;
            if (proj.screenX < -200 || proj.screenX > W + 200)
                continue;
            if (proj.screenY < -200 || proj.screenY > H + 200)
                continue;
            const opacity = ropeOpacity(proj.depth);
            if (opacity < 0.02)
                continue;
            const fontSize = Math.max(cfg.MIN_FONT_SIZE, cfg.BASE_FONT_SIZE * proj.scale);
            if (fontSize < 5)
                continue;
            projectedWords.push({
                word,
                x: proj.screenX / W,
                y: proj.screenY / H,
                scale: proj.scale,
                opacity,
                depth: proj.depth,
                isItalic: rope3d.wordItalicMap[i] || false
            });
        }
        projectedWords.sort((a, b) => b.depth - a.depth);
        streamState.projectedWords = projectedWords;
        streamState.showConnector = cfg.SHOW_CONNECTOR;
        streamState.wordOffset = rope3d.wordOffset;
        streamState.visibleWords = projectedWords.map(pw => pw.word);
    }
    else {
        const contentHtml = $('content')?.innerHTML || '';
        const contentWithSpaces = contentHtml.replace(/<br\s*\/?>/gi, ' ');
        const temp = document.createElement('div');
        temp.innerHTML = contentWithSpaces;
        const content = temp.textContent || '';
        streamState.text = content;
    }
    sendP2PMessage({
        type: 'stream-state',
        payload: streamState
    });
}
function handleP2PStreamState(message) {
    const peerId = message.peerId;
    const streamState = message.payload;
    if (peerId === p2p.peerId)
        return;
    if (!peerId || !streamState)
        return;
    if (!p2p.roomId || p2p.isLeaving)
        return;
    if (p2p.hiddenPeers.has(peerId))
        return;
    if (!p2p.streams.has(peerId)) {
        createStreamPIP(peerId);
    }
    if (streamState.type === 'search') {
        updateStreamPIPSearch(peerId, streamState);
        return;
    }
    updateStreamPIP(peerId, streamState);
}
function updateStreamPIPSearch(peerId, searchState) {
    const pip = p2p.streams.get(peerId);
    if (!pip)
        return;
    const contentEl = pip.querySelector(`#pip-content-${peerId}`);
    const canvasEl = pip.querySelector(`#pip-canvas-${peerId}`);
    const modeEl = pip.querySelector(`#pip-mode-${peerId}`);
    if (!contentEl)
        return;
    if (canvasEl)
        canvasEl.style.display = 'none';
    stopPIPCanvas(peerId);
    if (modeEl) {
        modeEl.textContent = '';
        modeEl.style.color = '#3b82f6';
    }
    contentEl.style.display = 'block';
    contentEl.style.minHeight = '120px';
    const peer = p2p.peers.get(peerId);
    const peerName = peer?.displayName || 'Peer';
    let html = `<div style="font-size:11px;color:#888;margin-bottom:6px;padding:0 8px;">${escapeHtml(peerName)} is searching${searchState.isTyping ? '...' : ''}</div>`;
    if (searchState.query) {
        html += `<div style="padding:4px 8px;background:rgba(59,130,246,0.1);border-left:2px solid #3b82f6;margin:0 8px 8px;font-style:italic;">${escapeHtml(searchState.query)}</div>`;
    }
    if (searchState.results && searchState.results.length > 0) {
        html += '<div style="padding:0 8px;font-size:12px;">';
        searchState.results.slice(0, 3).forEach(book => {
            html += `<div style="padding:2px 0;"><a href="/read#${book.id}" style="color:#3b82f6;text-decoration:none;">#${book.id} ${escapeHtml(book.title)}</a></div>`;
        });
        if (searchState.results.length > 3) {
            html += `<div style="color:#888;">+${searchState.results.length - 3} more</div>`;
        }
        html += '</div>';
    }
    else if (searchState.query && searchState.query.length >= 2) {
        html += '<div style="padding:0 8px;color:#888;font-size:12px;font-style:italic;">No results</div>';
    }
    contentEl.innerHTML = html;
}
const pipCanvasState = new Map();
function createStreamPIP(peerId) {
    if (p2p.streams.has(peerId))
        return;
    const peer = p2p.peers.get(peerId);
    const container = p2pUI.streamsContainer();
    container.classList.add('active');
    const pip = document.createElement('div');
    pip.className = 'p2p-stream-pip';
    pip.id = `pip-${peerId}`;
    pip.style.cssText = 'right: 20px; bottom: 100px; width: 320px;';
    pip.innerHTML = `
    <div class="pip-header">
      <button class="pip-expand" data-peer-id="${peerId}" title="Expand to fullscreen"></button>
      <span class="pip-title">${escapeHtml(peer?.displayName || 'Peer')}</span>
      <span class="pip-mode" id="pip-mode-${peerId}" style="font-size:10px;color:#888;margin-left:8px;">2D</span>
      <div class="pip-controls">
        <button class="pip-collapse" data-peer-id="${peerId}" title="Collapse/Expand"></button>
        <button class="pip-close" data-peer-id="${peerId}" title="Close"></button>
      </div>
    </div>
    <div class="pip-content" id="pip-content-${peerId}" style="min-height:120px;">
      <div style="color:#888;font-style:italic;">Waiting for stream...</div>
    </div>
    <canvas id="pip-canvas-${peerId}" width="640" height="300" style="display:none;width:100%;height:150px;background:#0a0a0a;border-radius:0 0 8px 8px;"></canvas>
    <div class="pip-footer">
      <span class="pip-location" id="pip-location-${peerId}" title="Click to copy location"></span>
    </div>
  `;
    container.appendChild(pip);
    p2p.streams.set(peerId, pip);
    const locationEl = pip.querySelector(`#pip-location-${peerId}`);
    if (locationEl) {
        locationEl.addEventListener('click', () => {
            const location = locationEl.dataset.location;
            if (!location)
                return;
            navigator.clipboard.writeText(location).then(() => {
                locationEl.classList.add('copied');
                const originalText = locationEl.textContent;
                locationEl.textContent = 'Copied!';
                setTimeout(() => {
                    locationEl.classList.remove('copied');
                    locationEl.textContent = originalText;
                }, 1500);
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = location;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                locationEl.classList.add('copied');
                const originalText = locationEl.textContent;
                locationEl.textContent = 'Copied!';
                setTimeout(() => {
                    locationEl.classList.remove('copied');
                    locationEl.textContent = originalText;
                }, 1500);
            });
        });
    }
    container.appendChild(pip);
    p2p.streams.set(peerId, pip);
    const expandBtn = pip.querySelector('.pip-expand');
    expandBtn.addEventListener('mousedown', (e) => e.stopPropagation(), true);
    expandBtn.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
    }, { capture: true, passive: false });
    expandBtn.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
        expandBtn.click();
    }, { capture: true, passive: false });
    expandBtn.addEventListener('click', (e) => {
        e.stopImmediatePropagation();
        const isExpanded = pip.classList.contains('expanded');
        const canvas = pip.querySelector(`#pip-canvas-${peerId}`);
        if (isExpanded) {
            pip.classList.remove('expanded');
            pip.style.zIndex = '';
            const idx = p2p.expandedPips.indexOf(peerId);
            if (idx > -1)
                p2p.expandedPips.splice(idx, 1);
            if (canvas) {
                canvas.width = 640;
                canvas.height = 300;
            }
        }
        else {
            pip.classList.add('expanded');
            pip.classList.remove('collapsed');
            const idx = p2p.expandedPips.indexOf(peerId);
            if (idx > -1)
                p2p.expandedPips.splice(idx, 1);
            p2p.expandedPips.push(peerId);
            p2p.expandedPips.forEach((pid, i) => {
                const el = p2p.streams.get(pid);
                if (el && el.classList.contains('expanded')) {
                    el.style.zIndex = 10000 + i;
                }
            });
            if (canvas) {
                setTimeout(() => {
                    const rect = canvas.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width * (window.devicePixelRatio || 1);
                        canvas.height = rect.height * (window.devicePixelRatio || 1);
                    }
                }, 50);
            }
        }
    }, true);
    const collapseBtn = pip.querySelector('.pip-collapse');
    collapseBtn.addEventListener('mousedown', (e) => e.stopPropagation(), true);
    collapseBtn.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
    }, { capture: true, passive: false });
    collapseBtn.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
        collapseBtn.click();
    }, { capture: true, passive: false });
    collapseBtn.addEventListener('click', (e) => {
        e.stopImmediatePropagation();
        if (pip.classList.contains('expanded')) {
            pip.classList.remove('expanded');
            pip.style.zIndex = '';
            const idx = p2p.expandedPips.indexOf(peerId);
            if (idx > -1)
                p2p.expandedPips.splice(idx, 1);
            return;
        }
        pip.classList.toggle('collapsed');
        const collapseBtn = pip.querySelector('.pip-collapse');
        if (pip.classList.contains('collapsed')) {
            collapseBtn.textContent = '';
            collapseBtn.title = 'Expand';
        }
        else {
            collapseBtn.textContent = '';
            collapseBtn.title = 'Collapse';
        }
    }, true);
    const closeBtn = pip.querySelector('.pip-close');
    closeBtn.addEventListener('mousedown', (e) => e.stopPropagation(), true);
    closeBtn.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
    }, { capture: true, passive: false });
    closeBtn.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        e.preventDefault();
        leaveP2PRoom();
    }, { capture: true, passive: false });
    closeBtn.addEventListener('click', (e) => {
        e.stopImmediatePropagation();
        leaveP2PRoom();
    }, true);
    makeDraggable(pip, pip.querySelector('.pip-header'));
    p2pLog('p2p_follow', `Created PIP for ${peer?.displayName || peerId}`);
}
function removeStreamPIP(peerId) {
    const canvasState = pipCanvasState.get(peerId);
    if (canvasState && canvasState.animationId) {
        cancelAnimationFrame(canvasState.animationId);
        pipCanvasState.delete(peerId);
    }
    const pip = p2p.streams.get(peerId);
    if (pip) {
        pip.remove();
        p2p.streams.delete(peerId);
    }
    if (p2p.streams.size === 0) {
        p2pUI.streamsContainer().classList.remove('active');
    }
}
function renderPIP3DCanvas(peerId, streamState) {
    const pip = p2p.streams.get(peerId);
    if (!pip)
        return;
    const canvas = pip.querySelector(`#pip-canvas-${peerId}`);
    if (!canvas)
        return;
    const ctx = canvas.getContext('2d');
    let canvasState = pipCanvasState.get(peerId);
    if (!canvasState) {
        canvasState = { animationId: null, streamState: null };
        pipCanvasState.set(peerId, canvasState);
    }
    canvasState.streamState = streamState;
    if (!canvasState.animationId) {
        function animate() {
            canvasState.animationId = requestAnimationFrame(animate);
            const ss = canvasState.streamState;
            if (!ss)
                return;
            const width = canvas.width;
            const height = canvas.height;
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            if (ss.projectedWords && ss.projectedWords.length > 0) {
                const scaleFactor = Math.min(width / 1920, height / 1080);
                const baseFont = 42;
                if (ss.showConnector && ss.projectedWords.length > 1) {
                    const sortedByDepth = [...ss.projectedWords];
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(200, 200, 200, 0.45)`;
                    ctx.lineWidth = 1;
                    let started = false;
                    for (const pw of sortedByDepth) {
                        const sx = pw.x * width;
                        const sy = pw.y * height;
                        if (!started) {
                            ctx.moveTo(sx, sy);
                            started = true;
                        }
                        else {
                            ctx.lineTo(sx, sy);
                        }
                    }
                    ctx.stroke();
                }
                for (const pw of ss.projectedWords) {
                    const sx = pw.x * width;
                    const sy = pw.y * height;
                    const fontSize = Math.max(6, baseFont * pw.scale * scaleFactor);
                    if (fontSize < 4)
                        continue;
                    ctx.save();
                    ctx.translate(sx, sy);
                    const fontStyle = pw.isItalic ? 'italic ' : '';
                    ctx.font = `${fontStyle}${Math.round(fontSize)}px Georgia, serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = `rgba(255, 255, 255, ${pw.opacity})`;
                    ctx.fillText(pw.word, 0, 0);
                    ctx.restore();
                }
            }
            else if (ss.visibleWords && ss.visibleWords.length > 0) {
                const centerX = width / 2;
                const centerY = height * 0.3;
                const spacing = 1.5;
                const vanishingPointZ = 20;
                const baseFont = Math.max(24, height * 0.16);
                ss.visibleWords.forEach((word, i) => {
                    const z = i * spacing + 0.5;
                    const scale = vanishingPointZ / (vanishingPointZ + z);
                    const y = centerY + (z * height * 0.027 * scale);
                    const fontSize = Math.max(8, baseFont * scale);
                    const opacity = Math.max(0.1, Math.min(1, 1 - z / 15));
                    ctx.font = `${fontSize}px Georgia, serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.fillText(word, centerX, y);
                });
            }
        }
        animate();
    }
}
function stopPIPCanvas(peerId) {
    const state = pipCanvasState.get(peerId);
    if (state && state.animationId) {
        cancelAnimationFrame(state.animationId);
        state.animationId = null;
    }
    pipCanvasState.delete(peerId);
}
function updateStreamPIP(peerId, streamState) {
    const pip = p2p.streams.get(peerId);
    if (!pip)
        return;
    const contentEl = pip.querySelector(`#pip-content-${peerId}`);
    const canvasEl = pip.querySelector(`#pip-canvas-${peerId}`);
    const modeEl = pip.querySelector(`#pip-mode-${peerId}`);
    const locationEl = pip.querySelector(`#pip-location-${peerId}`);
    if (!contentEl || !canvasEl)
        return;
    const is3D = streamState.mode === '3d';
    pip.classList.toggle('pip-3d-mode', is3D);
    if (modeEl) {
        modeEl.textContent = is3D ? '3D' : '2D';
        modeEl.style.color = is3D ? '#4a9' : '#888';
    }
    if (locationEl && streamState.byteStart !== undefined && streamState.bookId) {
        const chunkSize = streamState.chunkSize || 200;
        const is3dMode = streamState.mode === '3d';
        const hash = `#${streamState.bookId},${streamState.byteStart},${chunkSize}${is3dMode ? ',3d' : ''}`;
        const fullUrl = window.location.origin + '/read' + hash;
        locationEl.textContent = `${streamState.bookId},${streamState.byteStart},${chunkSize}`;
        locationEl.dataset.location = fullUrl;
        locationEl.title = `Click to copy URL`;
    }
    const bookInfo = streamState.bookTitle
        ? `<div style="font-size:11px;color:#888;margin-bottom:6px;padding:0 8px;">${escapeHtml(streamState.bookTitle)}${streamState.bookAuthor ? '  ' + escapeHtml(streamState.bookAuthor) : ''}  ${streamState.percent || '0%'}</div>`
        : '';
    if (is3D && (streamState.projectedWords?.length > 0 || streamState.visibleWords?.length > 0)) {
        contentEl.innerHTML = bookInfo || '<div style="height:20px;"></div>';
        contentEl.style.display = 'block';
        contentEl.style.minHeight = 'auto';
        canvasEl.style.display = 'block';
        renderPIP3DCanvas(peerId, streamState);
    }
    else {
        contentEl.style.display = 'block';
        contentEl.style.minHeight = '120px';
        canvasEl.style.display = 'none';
        stopPIPCanvas(peerId);
        let displayText = '';
        if (streamState.text) {
            displayText = streamState.text;
        }
        else if (streamState.visibleWords && streamState.visibleWords.length > 0) {
            displayText = streamState.visibleWords.join(' ');
        }
        contentEl.innerHTML = bookInfo + (displayText ? `<div style="padding:0 8px;">${processItalics(displayText)}</div>` : '<em style="color:#666;padding:0 8px;">Waiting for content...</em>');
    }
}
function makeDraggable(element, handle) {
    let isDragging = false;
    let startX, startY, startRight, startBottom;
    function getCoords(e) {
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }
    function startDrag(e) {
        if (element.classList.contains('expanded'))
            return;
        if (e.target.closest('button'))
            return;
        isDragging = true;
        const coords = getCoords(e);
        startX = coords.x;
        startY = coords.y;
        startRight = parseInt(element.style.right) || 20;
        startBottom = parseInt(element.style.bottom) || 100;
        e.preventDefault();
    }
    function moveDrag(e) {
        if (!isDragging)
            return;
        const coords = getCoords(e);
        const deltaX = startX - coords.x;
        const deltaY = startY - coords.y;
        element.style.right = Math.max(0, startRight + deltaX) + 'px';
        element.style.bottom = Math.max(0, startBottom + deltaY) + 'px';
    }
    function endDrag() {
        isDragging = false;
    }
    handle.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', moveDrag);
    document.addEventListener('mouseup', endDrag);
    element.addEventListener('touchstart', startDrag, { passive: false });
    document.addEventListener('touchmove', moveDrag, { passive: false });
    document.addEventListener('touchend', endDrag);
}
function toggleP2PPanel() {
    p2pUI.panel().classList.toggle('visible');
}
function createP2PRoom() {
    const displayName = p2pUI.displayName().value.trim() || `User ${Math.floor(Math.random() * 1000)}`;
    p2p.joiningRoom = true;
    sendP2PMessage({
        type: 'create-room',
        payload: {
            displayName,
            name: `${displayName}'s Room`
        }
    });
    p2pLog('p2p', `Creating room as "${displayName}"`);
}
function createP2PRoomWithId(roomId, displayName) {
    displayName = displayName || p2pUI.displayName()?.value?.trim() || `User ${Math.floor(Math.random() * 1000)}`;
    p2p.joiningRoom = true;
    sendP2PMessage({
        type: 'create-room',
        payload: {
            roomId,
            displayName,
            name: `${displayName}'s Room`
        }
    });
    p2pLog('p2p', `Creating room ${roomId} as "${displayName}"`);
}
function joinP2PRoom(roomCodeArg, displayNameArg) {
    let roomCode = '';
    if (typeof roomCodeArg === 'string') {
        roomCode = roomCodeArg.trim().toUpperCase();
    }
    else {
        const input = p2pUI.roomCodeInput();
        if (input && input.value) {
            roomCode = String(input.value).trim().toUpperCase();
        }
    }
    let displayName = '';
    if (typeof displayNameArg === 'string') {
        displayName = displayNameArg.trim();
    }
    else {
        const input = p2pUI.displayName();
        if (input && input.value) {
            displayName = String(input.value).trim();
        }
    }
    if (!displayName) {
        displayName = `User ${Math.floor(Math.random() * 1000)}`;
    }
    if (!roomCode || roomCode.length < 4) {
        showHint('Enter a valid room code');
        return;
    }
    p2p.joiningRoom = true;
    sendP2PMessage({
        type: 'join-room',
        roomId: roomCode,
        payload: { displayName }
    });
    p2pLog('p2p', `Joining room ${roomCode} as "${displayName}"`);
}
function leaveP2PRoom() {
    if (p2p.isLeaving)
        return;
    if (p2p.peers.size > 1) {
        if (!confirm('Leave this room?\nAll your Reading Room connections will close.')) {
            return;
        }
    }
    p2p.isLeaving = true;
    p2p.joiningRoom = false;
    const wasRoomId = p2p.roomId;
    p2p.roomId = null;
    p2p.streams.forEach((pip, peerId) => {
        removeStreamPIP(peerId);
    });
    stopSharing();
    if (wasRoomId) {
        sendP2PMessage({ type: 'leave-room' });
        p2pLog('p2p', 'Left room');
    }
    p2p.peers.clear();
    p2p.hiddenPeers.clear();
    p2p.expandedPips = [];
    clearSavedP2PRoom();
    updateP2PUI();
    p2p.isLeaving = false;
}
function copyP2PRoomCode() {
    navigator.clipboard.writeText(p2p.roomId).then(() => {
        $('p2pCopyCode').textContent = 'Copied!';
        setTimeout(() => {
            $('p2pCopyCode').textContent = 'Copy Code';
        }, 2000);
    });
}
$('p2pToggle').addEventListener('click', toggleP2PPanel);
$('p2pClose').addEventListener('click', () => p2pUI.panel().classList.remove('visible'));
$('p2pCreateBtn').addEventListener('click', createP2PRoom);
$('p2pJoinBtn').addEventListener('click', joinP2PRoom);
$('p2pLeaveBtn').addEventListener('click', leaveP2PRoom);
$('p2pCopyCode').addEventListener('click', copyP2PRoomCode);
$('p2pRoomCodeInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter')
        joinP2PRoom();
});
if (!isExcerptMode()) {
    setTimeout(initP2PSignaling, 500);
}
loadBookmarksFromStorage();

try {
    if (isExcerptMode()) {
        initExcerptMode();
    }
    else {
        const params = parseHash();
        if (params) {
            state.chunkSize = params.chunkSize;
            initBook(params.bookId, params.byteStart, params.chunkSize).then((data) => {
                if (data && params.mode === '3d' && !rope3d.active) {
                    toggleRopeMode();
                }
            });
        }
        else {
            loadLastPosition().then(lastPos => {
                if (lastPos && lastPos.bookId) {
                    state.chunkSize = lastPos.chunkSize || 200;
                    initBook(lastPos.bookId, lastPos.byteStart, state.chunkSize).then((data) => {
                        if (data && lastPos.mode === '3d' && !rope3d.active) {
                            toggleRopeMode();
                        }
                    });
                }
                else {
                    $('content').className = 'error';
                    $('content').textContent = 'No book specified. Use URL like /read#1342 or search for a book.';
                }
            }).catch(() => {
                $('content').className = 'error';
                $('content').textContent = 'No book specified. Use URL like /read#1342 or search for a book.';
            });
        }
    }
}
catch (err) {
    console.error('Initial load error:', err);
    $('content').className = 'error';
    $('content').textContent = `Initialization error: ${err.message}`;
}
$('mainContent').focus();

  </script>
</body>
</html>
